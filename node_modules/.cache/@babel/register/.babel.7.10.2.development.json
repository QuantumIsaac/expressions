{
  "{\"sourceRoot\":\"/home/isaac/Personal/parsers/\",\"caller\":{\"name\":\"@babel/node\"},\"cwd\":\"/home/isaac/Personal/parsers\",\"filename\":\"/home/isaac/Personal/parsers/boolexp.js\",\"babelrc\":false,\"configFile\":false,\"passPerPreset\":false,\"envName\":\"development\",\"root\":\"/home/isaac/Personal/parsers\",\"plugins\":[],\"presets\":[]}:7.10.2": {
    "metadata": {},
    "options": {
      "sourceRoot": "/home/isaac/Personal/parsers/",
      "caller": {
        "name": "@babel/node"
      },
      "cwd": "/home/isaac/Personal/parsers",
      "filename": "/home/isaac/Personal/parsers/boolexp.js",
      "babelrc": false,
      "configFile": false,
      "envName": "development",
      "root": "/home/isaac/Personal/parsers",
      "sourceMaps": "both",
      "ast": false,
      "passPerPreset": false,
      "plugins": [],
      "presets": [],
      "parserOpts": {
        "sourceType": "module",
        "sourceFileName": "/home/isaac/Personal/parsers/boolexp.js",
        "plugins": []
      },
      "generatorOpts": {
        "filename": "/home/isaac/Personal/parsers/boolexp.js",
        "comments": true,
        "compact": "auto",
        "sourceMaps": "both",
        "sourceRoot": "/home/isaac/Personal/parsers/",
        "sourceFileName": "boolexp.js"
      }
    },
    "ast": null,
    "code": "// Boolean Expressions Parser/Evaluator\nconst OPERATOR = {\n  // operator precedence\n  '*': {\n    precedence: 2,\n    binary: true,\n    fn: (a, b) => a && b\n  },\n  '+': {\n    precedence: 1,\n    binary: true,\n    fn: (a, b) => a || b\n  },\n  '~': {\n    binary: false,\n    fn: a => !a\n  }\n};\n\nconst isBinaryOperator = chr => Object.keys(OPERATOR).filter(op => op.binary).includes(chr);\n\nconst isUnaryOperator = chr => Object.keys(OPERATOR).filter(op => !op.binary).includes(chr);\n\nconst stackify = arr => {\n  arr = arr || [];\n\n  arr.peek = () => arr[arr.length - 1];\n\n  return arr;\n};\n\nconst makeTreeNode = (op, a, b) => {\n  return {\n    value: op,\n    children: [a, b]\n  };\n};\n\nconst parseExpression = exp => {\n  const operator_stack = stackify();\n  const operand_stack = stackify();\n  let unique_tokens = [];\n  let token = '';\n  let unaryOp = 0;\n\n  const pushToken = () => {\n    operand_stack.push(token);\n    aggregateUnaryOp();\n    if (!unique_tokens.includes(token)) unique_tokens.push(token);\n    token = '';\n  };\n\n  const aggregateUnaryOp = () => {\n    while (unaryOp > 0) {\n      let op = operator_stack.pop();\n      let operand = operand_stack.pop();\n      operand_stack.push({\n        value: op,\n        children: [operand]\n      });\n      unaryOp--;\n    }\n  };\n\n  let grabbingExpression = false;\n  let expression = '';\n  let expParen = 0;\n\n  for (let char of exp) {\n    // first check if grabbing expression\n    if (grabbingExpression) {\n      if (char === '(') {\n        expParen++;\n        expression += '(';\n      } else if (char === ')') {\n        expParen--;\n\n        if (expParen === 0) {\n          let exp = parseExpression(expression);\n          let exp_tk = exp.tokens;\n\n          for (let token of exp_tk) {\n            if (!unique_tokens.includes(token)) unique_tokens.push(token);\n          }\n\n          delete exp.tokens; // remove extraneous data from internal tree nodes\n\n          operand_stack.push(exp);\n          aggregateUnaryOp();\n          expression = '';\n          grabbingExpression = false;\n        } else {\n          expression += ')';\n        }\n      } else expression += char;\n\n      continue;\n    }\n\n    if (/\\s/.test(char)) {\n      if (token !== '') pushToken();\n    } else if (/[a-zA-Z0-9_]/.test(char)) {\n      token += char;\n    } else {\n      if (token !== '') pushToken();\n\n      if (isBinaryOperator(char)) {\n        if (operator_stack.length > 0 && OPERATOR[char].precedence < OPERATOR[operator_stack.peek()].precedence) {\n          const op1 = operand_stack.pop();\n          const op2 = operand_stack.pop();\n          const op = operator_stack.pop();\n          operand_stack.push(makeTreeNode(op, op1, op2));\n        }\n\n        operator_stack.push(char);\n      } else if (isUnaryOperator(char)) {\n        unaryOp++;\n        operator_stack.push(char);\n      } else if (char === '(') {\n        grabbingExpression = true;\n        expParen++;\n      } else {\n        throw new Error(`Unexpected character '${char}'`);\n      }\n    }\n  }\n\n  if (grabbingExpression) {\n    throw new Error('Expression contains unmatched opening parenthesis.');\n  }\n\n  if (token !== '') pushToken();\n\n  while (operator_stack.length > 0) {\n    let op1 = operand_stack.pop();\n    let op2 = operand_stack.pop();\n    let op = operator_stack.pop();\n    operand_stack.push(makeTreeNode(op, op1, op2));\n  }\n\n  if (operand_stack.length > 1) {\n    throw new Error('Too many operands!');\n  }\n\n  let retObj = operand_stack[0];\n\n  if (typeof retObj === 'string') {\n    retObj = {\n      value: retObj,\n      children: []\n    };\n  }\n\n  retObj.tokens = unique_tokens;\n  return operand_stack[0]; // should be the expression tree (or a single-token string)\n};\n\nfunction evaluateTree(treeHead, values) {\n  values[true] = true;\n  values[false] = false;\n\n  if (typeof treeHead === 'string') {\n    if (treeHead[0] === '~') {\n      return !values[treeHead[0].substring(1)];\n    } else {\n      return values[treeHead[0]];\n    }\n  }\n\n  let maybeInvert = val => treeHead.invert ? !val : val;\n\n  let op = treeHead.value;\n  let op1 = treeHead.children[0];\n  let op2 = treeHead.children[1];\n  let operand1;\n  let operand2;\n\n  if (typeof op1 === 'object') {\n    operand1 = evaluateTree(op1, values);\n  }\n\n  if (typeof op2 === 'object') {\n    operand2 = evaluateTree(op2, values);\n  }\n\n  if (typeof op1 === \"string\") {\n    if (op1[0] === '~') {\n      operand1 = !values[op1.substring(1)];\n    } else {\n      operand1 = values[op1];\n    }\n  }\n\n  if (typeof op2 === \"string\") {\n    if (op2[0] === '~') {\n      operand2 = !values[op2.substring(1)];\n    } else {\n      operand2 = values[op2];\n    }\n  }\n\n  return maybeInvert(OPERATOR[op].fn(operand1, operand2));\n}\n\n;\nexport { parseExpression, evaluateTree };\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImJvb2xleHAuanMiXSwibmFtZXMiOlsiT1BFUkFUT1IiLCJwcmVjZWRlbmNlIiwiYmluYXJ5IiwiZm4iLCJhIiwiYiIsImlzQmluYXJ5T3BlcmF0b3IiLCJjaHIiLCJPYmplY3QiLCJrZXlzIiwiZmlsdGVyIiwib3AiLCJpbmNsdWRlcyIsImlzVW5hcnlPcGVyYXRvciIsInN0YWNraWZ5IiwiYXJyIiwicGVlayIsImxlbmd0aCIsIm1ha2VUcmVlTm9kZSIsInZhbHVlIiwiY2hpbGRyZW4iLCJwYXJzZUV4cHJlc3Npb24iLCJleHAiLCJvcGVyYXRvcl9zdGFjayIsIm9wZXJhbmRfc3RhY2siLCJ1bmlxdWVfdG9rZW5zIiwidG9rZW4iLCJ1bmFyeU9wIiwicHVzaFRva2VuIiwicHVzaCIsImFnZ3JlZ2F0ZVVuYXJ5T3AiLCJwb3AiLCJvcGVyYW5kIiwiZ3JhYmJpbmdFeHByZXNzaW9uIiwiZXhwcmVzc2lvbiIsImV4cFBhcmVuIiwiY2hhciIsImV4cF90ayIsInRva2VucyIsInRlc3QiLCJvcDEiLCJvcDIiLCJFcnJvciIsInJldE9iaiIsImV2YWx1YXRlVHJlZSIsInRyZWVIZWFkIiwidmFsdWVzIiwic3Vic3RyaW5nIiwibWF5YmVJbnZlcnQiLCJ2YWwiLCJpbnZlcnQiLCJvcGVyYW5kMSIsIm9wZXJhbmQyIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUVBLE1BQU1BLFFBQVEsR0FBRztBQUNoQjtBQUNBLE9BQUs7QUFDRUMsSUFBQUEsVUFBVSxFQUFFLENBRGQ7QUFFRUMsSUFBQUEsTUFBTSxFQUFFLElBRlY7QUFHSkMsSUFBQUEsRUFBRSxFQUFFLENBQUNDLENBQUQsRUFBSUMsQ0FBSixLQUFVRCxDQUFDLElBQUlDO0FBSGYsR0FGVztBQU9oQixPQUFLO0FBQ0VKLElBQUFBLFVBQVUsRUFBRSxDQURkO0FBRUVDLElBQUFBLE1BQU0sRUFBRSxJQUZWO0FBR0pDLElBQUFBLEVBQUUsRUFBRSxDQUFDQyxDQUFELEVBQUlDLENBQUosS0FBVUQsQ0FBQyxJQUFJQztB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ZXJzb25hbC9wYXJzZXJzLyIsInNvdXJjZXNDb250ZW50IjpbIi8vIEJvb2xlYW4gRXhwcmVzc2lvbnMgUGFyc2VyL0V2YWx1YXRvclxuXG5jb25zdCBPUEVSQVRPUiA9IHtcblx0Ly8gb3BlcmF0b3IgcHJlY2VkZW5jZVxuXHQnKic6IHtcbiAgICAgICAgcHJlY2VkZW5jZTogMixcbiAgICAgICAgYmluYXJ5OiB0cnVlLFxuXHRcdGZuOiAoYSwgYikgPT4gYSAmJiBiXG5cdH0sXG5cdCcrJzoge1xuICAgICAgICBwcmVjZWRlbmNlOiAxLFxuICAgICAgICBiaW5hcnk6IHRydWUsXG5cdFx0Zm46IChhLCBiKSA9PiBhIHx8IGJcbiAgICB9LFxuICAgICd+Jzoge1xuICAgICAgICBiaW5hcnk6IGZhbHNlLFxuICAgICAgICBmbjogYSA9PiAhYVxuICAgIH1cbn07XG5cbmNvbnN0IGlzQmluYXJ5T3BlcmF0b3IgPSBjaHIgPT4gT2JqZWN0LmtleXMoT1BFUkFUT1IpLmZpbHRlcihvcCA9PiBvcC5iaW5hcnkpLmluY2x1ZGVzKGNocik7XG5jb25zdCBpc1VuYXJ5T3BlcmF0b3IgPSBjaHIgPT4gT2JqZWN0LmtleXMoT1BFUkFUT1IpLmZpbHRlcihvcCA9PiAhb3AuYmluYXJ5KS5pbmNsdWRlcyhjaHIpO1xuY29uc3Qgc3RhY2tpZnkgPSBhcnIgPT4ge1xuXHRhcnIgPSBhcnIgfHwgW107XG5cdGFyci5wZWVrID0gKCkgPT4gYXJyW2Fyci5sZW5ndGgtMV07XG5cdHJldHVybiBhcnI7XG59O1xuXG5jb25zdCBtYWtlVHJlZU5vZGUgPSAob3AsIGEsIGIpID0+IHtcblx0cmV0dXJuIHtcblx0XHR2YWx1ZTogb3AsXG5cdFx0Y2hpbGRyZW46IFthLCBiXVxuXHR9XG59O1xuXG5jb25zdCBwYXJzZUV4cHJlc3Npb24gPSBleHAgPT4ge1xuXHRjb25zdCBvcGVyYXRvcl9zdGFjayA9IHN0YWNraWZ5KCk7XG5cdGNvbnN0IG9wZXJhbmRfc3RhY2sgPSBzdGFja2lmeSgpO1xuXG5cdGxldCB1bmlxdWVfdG9rZW5zID0gW107XG5cbiAgICBsZXQgdG9rZW4gPSAnJztcblx0bGV0IHVuYXJ5T3AgPSAwO1xuXHRjb25zdCBwdXNoVG9rZW4gPSAoKSA9PiB7XG4gICAgICAgIG9wZXJhbmRfc3RhY2sucHVzaCh0b2tlbik7XG4gICAgICAgIGFnZ3JlZ2F0ZVVuYXJ5T3AoKTtcblx0XHRpZiggIXVuaXF1ZV90b2tlbnMuaW5jbHVkZXModG9rZW4pICkgdW5pcXVlX3Rva2Vucy5wdXNoKHRva2VuKTtcblx0XHR0b2tlbiA9ICcnO1xuICAgIH07XG4gICAgXG4gICAgY29uc3QgYWdncmVnYXRlVW5hcnlPcCA9ICgpID0+IHtcbiAgICAgICAgd2hpbGUoIHVuYXJ5T3AgPiAwICkge1xuICAgICAgICAgICAgbGV0IG9wID0gb3BlcmF0b3Jfc3RhY2sucG9wKCk7XG4gICAgICAgICAgICBsZXQgb3BlcmFuZCA9IG9wZXJhbmRfc3RhY2sucG9wKCk7XG4gICAgICAgICAgICBvcGVyYW5kX3N0YWNrLnB1c2goe1xuICAgICAgICAgICAgICAgIHZhbHVlOiBvcCxcbiAgICAgICAgICAgICAgICBjaGlsZHJlbjogW29wZXJhbmRdXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHVuYXJ5T3AtLTtcbiAgICAgICAgfVxuICAgIH07XG5cblx0bGV0IGdyYWJiaW5nRXhwcmVzc2lvbiA9IGZhbHNlO1xuXHRsZXQgZXhwcmVzc2lvbiA9ICcnO1xuXHRsZXQgZXhwUGFyZW4gPSAwO1xuXHRmb3IoIGxldCBjaGFyIG9mIGV4cCApIHtcblx0XHQvLyBmaXJzdCBjaGVjayBpZiBncmFiYmluZyBleHByZXNzaW9uXG5cdFx0aWYoIGdyYWJiaW5nRXhwcmVzc2lvbiApIHtcblx0XHRcdGlmKCBjaGFyID09PSAnKCcgKSB7XG5cdFx0XHRcdGV4cFBhcmVuKys7XG5cdFx0XHRcdGV4cHJlc3Npb24gKz0gJygnO1xuXHRcdFx0fSBlbHNlIGlmKCBjaGFyID09PSAnKScgKSB7XG5cdFx0XHRcdGV4cFBhcmVuLS07XG5cdFx0XHRcdGlmKCBleHBQYXJlbiA9PT0gMCApIHtcblx0XHRcdFx0XHRsZXQgZXhwID0gcGFyc2VFeHByZXNzaW9uKGV4cHJlc3Npb24pO1xuICAgICAgICAgICAgICAgICAgICBsZXQgZXhwX3RrID0gZXhwLnRva2VucztcbiAgICAgICAgICAgICAgICAgICAgZm9yKCBsZXQgdG9rZW4gb2YgZXhwX3RrICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYoICF1bmlxdWVfdG9rZW5zLmluY2x1ZGVzKHRva2VuKSApIHVuaXF1ZV90b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGV4cC50b2tlbnM7IC8vIHJlbW92ZSBleHRyYW5lb3VzIGRhdGEgZnJvbSBpbnRlcm5hbCB0cmVlIG5vZGVzXG4gICAgICAgICAgICAgICAgICAgIG9wZXJhbmRfc3RhY2sucHVzaChleHApO1xuICAgICAgICAgICAgICAgICAgICBhZ2dyZWdhdGVVbmFyeU9wKCk7XG5cdFx0XHRcdFx0ZXhwcmVzc2lvbiA9ICcnO1xuXHRcdFx0XHRcdGdyYWJiaW5nRXhwcmVzc2lvbiA9IGZhbHNlO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGV4cHJlc3Npb24gKz0gJyknO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2UgZXhwcmVzc2lvbiArPSBjaGFyO1xuXHRcdFx0Y29udGludWU7XG5cdFx0fVxuXG5cdFx0aWYoIC9cXHMvLnRlc3QoY2hhcikgKSB7XG5cdFx0XHRpZiggdG9rZW4gIT09ICcnICkgcHVzaFRva2VuKCk7XG5cdFx0fSBlbHNlIGlmKCAvW2EtekEtWjAtOV9dLy50ZXN0KGNoYXIpICkge1xuXHRcdFx0dG9rZW4gKz0gY2hhcjtcblx0XHR9IGVsc2Uge1xuXHRcdFx0aWYoIHRva2VuICE9PSAnJyApIHB1c2hUb2tlbigpO1xuXHRcdFx0aWYoIGlzQmluYXJ5T3BlcmF0b3IoY2hhcikgKSB7XG5cdFx0XHRcdGlmKCBvcGVyYXRvcl9zdGFjay5sZW5ndGggPiAwICYmIE9QRVJBVE9SW2NoYXJdLnByZWNlZGVuY2UgPCBPUEVSQVRPUltvcGVyYXRvcl9zdGFjay5wZWVrKCldLnByZWNlZGVuY2UgKSB7XG5cdFx0XHRcdFx0Y29uc3Qgb3AxID0gb3BlcmFuZF9zdGFjay5wb3AoKTtcblx0XHRcdFx0XHRjb25zdCBvcDIgPSBvcGVyYW5kX3N0YWNrLnBvcCgpO1xuXHRcdFx0XHRcdGNvbnN0IG9wID0gb3BlcmF0b3Jfc3RhY2sucG9wKCk7XG5cdFx0XHRcdFx0b3BlcmFuZF9zdGFjay5wdXNoKG1ha2VUcmVlTm9kZShvcCwgb3AxLCBvcDIpKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRvcGVyYXRvcl9zdGFjay5wdXNoKGNoYXIpO1xuXHRcdFx0fSBlbHNlIGlmKCBpc1VuYXJ5T3BlcmF0b3IoY2hhcikgKSB7XG4gICAgICAgICAgICAgICAgdW5hcnlPcCsrO1xuICAgICAgICAgICAgICAgIG9wZXJhdG9yX3N0YWNrLnB1c2goY2hhcik7XG4gICAgICAgICAgICB9ZWxzZSBpZiggY2hhciA9PT0gJygnICkge1xuXHRcdFx0XHRncmFiYmluZ0V4cHJlc3Npb24gPSB0cnVlO1xuXHRcdFx0XHRleHBQYXJlbisrO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKGBVbmV4cGVjdGVkIGNoYXJhY3RlciAnJHtjaGFyfSdgKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRpZiggZ3JhYmJpbmdFeHByZXNzaW9uICkge1xuXHRcdHRocm93IG5ldyBFcnJvcignRXhwcmVzc2lvbiBjb250YWlucyB1bm1hdGNoZWQgb3BlbmluZyBwYXJlbnRoZXNpcy4nKTtcblx0fVxuXG5cdGlmKCB0b2tlbiAhPT0gJycgKSBwdXNoVG9rZW4oKTtcblxuXHR3aGlsZShvcGVyYXRvcl9zdGFjay5sZW5ndGggPiAwKSB7XG5cdFx0bGV0IG9wMSA9IG9wZXJhbmRfc3RhY2sucG9wKCk7XG5cdFx0bGV0IG9wMiA9IG9wZXJhbmRfc3RhY2sucG9wKCk7XG5cdFx0bGV0IG9wID0gb3BlcmF0b3Jfc3RhY2sucG9wKCk7XG5cdFx0b3BlcmFuZF9zdGFjay5wdXNoKG1ha2VUcmVlTm9kZShvcCwgb3AxLCBvcDIpKTtcblx0fVxuXHRpZiggb3BlcmFuZF9zdGFjay5sZW5ndGggPiAxICkge1xuXHRcdHRocm93IG5ldyBFcnJvcignVG9vIG1hbnkgb3BlcmFuZHMhJyk7XG4gICAgfVxuXG4gICAgbGV0IHJldE9iaiA9IG9wZXJhbmRfc3RhY2tbMF07XG4gICAgaWYoIHR5cGVvZiByZXRPYmogPT09ICdzdHJpbmcnICkge1xuICAgICAgICByZXRPYmogPSB7XG4gICAgICAgICAgICB2YWx1ZTogcmV0T2JqLFxuICAgICAgICAgICAgY2hpbGRyZW46IFtdXG4gICAgICAgIH07XG4gICAgfVxuXHRyZXRPYmoudG9rZW5zID0gdW5pcXVlX3Rva2VucztcblxuXHRyZXR1cm4gb3BlcmFuZF9zdGFja1swXTsgLy8gc2hvdWxkIGJlIHRoZSBleHByZXNzaW9uIHRyZWUgKG9yIGEgc2luZ2xlLXRva2VuIHN0cmluZylcbn07XG5cbmZ1bmN0aW9uIGV2YWx1YXRlVHJlZSh0cmVlSGVhZCwgdmFsdWVzKSB7XG5cdHZhbHVlc1t0cnVlXSA9IHRydWU7XG5cdHZhbHVlc1tmYWxzZV0gPSBmYWxzZTtcblxuXHRpZiggdHlwZW9mIHRyZWVIZWFkID09PSAnc3RyaW5nJyApIHtcblx0XHRpZiggdHJlZUhlYWRbMF0gPT09ICd+JyApIHtcblx0XHRcdHJldHVybiAhdmFsdWVzW3RyZWVIZWFkWzBdLnN1YnN0cmluZygxKV1cblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIHZhbHVlc1t0cmVlSGVhZFswXV07XG5cdFx0fVxuXHR9XG5cblx0bGV0IG1heWJlSW52ZXJ0ID0gKHZhbCkgPT4gKHRyZWVIZWFkLmludmVydCA/ICF2YWwgOiB2YWwpO1xuXG5cdGxldCBvcCA9IHRyZWVIZWFkLnZhbHVlO1xuXHRsZXQgb3AxID0gdHJlZUhlYWQuY2hpbGRyZW5bMF07XG5cdGxldCBvcDIgPSB0cmVlSGVhZC5jaGlsZHJlblsxXTtcblxuXHRsZXQgb3BlcmFuZDE7XG5cdGxldCBvcGVyYW5kMjtcblx0aWYoIHR5cGVvZiBvcDEgPT09ICdvYmplY3QnICkge1xuXHRcdG9wZXJhbmQxID0gZXZhbHVhdGVUcmVlKG9wMSwgdmFsdWVzKTtcblx0fVxuXHRpZiggdHlwZW9mIG9wMiA9PT0gJ29iamVjdCcgKSB7XG5cdFx0b3BlcmFuZDIgPSBldmFsdWF0ZVRyZWUob3AyLCB2YWx1ZXMpO1xuXHR9XG5cblx0aWYoIHR5cGVvZiBvcDEgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0aWYoIG9wMVswXSA9PT0gJ34nICkge1xuXHRcdFx0b3BlcmFuZDEgPSAhdmFsdWVzW29wMS5zdWJzdHJpbmcoMSldO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRvcGVyYW5kMSA9IHZhbHVlc1tvcDFdO1xuXHRcdH1cblx0fVxuXHRpZiggdHlwZW9mIG9wMiA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRpZiggb3AyWzBdID09PSAnficgKSB7XG5cdFx0XHRvcGVyYW5kMiA9ICF2YWx1ZXNbb3AyLnN1YnN0cmluZygxKV07XG5cdFx0fSBlbHNlIHtcblx0XHRcdG9wZXJhbmQyID0gdmFsdWVzW29wMl07XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIG1heWJlSW52ZXJ0KE9QRVJBVE9SW29wXS5mbihvcGVyYW5kMSwgb3BlcmFuZDIpKTtcbn07XG5cbmV4cG9ydCB7IHBhcnNlRXhwcmVzc2lvbiwgZXZhbHVhdGVUcmVlIH07Il19",
    "map": {
      "version": 3,
      "sources": [
        "boolexp.js"
      ],
      "names": [
        "OPERATOR",
        "precedence",
        "binary",
        "fn",
        "a",
        "b",
        "isBinaryOperator",
        "chr",
        "Object",
        "keys",
        "filter",
        "op",
        "includes",
        "isUnaryOperator",
        "stackify",
        "arr",
        "peek",
        "length",
        "makeTreeNode",
        "value",
        "children",
        "parseExpression",
        "exp",
        "operator_stack",
        "operand_stack",
        "unique_tokens",
        "token",
        "unaryOp",
        "pushToken",
        "push",
        "aggregateUnaryOp",
        "pop",
        "operand",
        "grabbingExpression",
        "expression",
        "expParen",
        "char",
        "exp_tk",
        "tokens",
        "test",
        "op1",
        "op2",
        "Error",
        "retObj",
        "evaluateTree",
        "treeHead",
        "values",
        "substring",
        "maybeInvert",
        "val",
        "invert",
        "operand1",
        "operand2"
      ],
      "mappings": "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",
      "sourceRoot": "/home/isaac/Personal/parsers/",
      "sourcesContent": [
        "// Boolean Expressions Parser/Evaluator\n\nconst OPERATOR = {\n\t// operator precedence\n\t'*': {\n        precedence: 2,\n        binary: true,\n\t\tfn: (a, b) => a && b\n\t},\n\t'+': {\n        precedence: 1,\n        binary: true,\n\t\tfn: (a, b) => a || b\n    },\n    '~': {\n        binary: false,\n        fn: a => !a\n    }\n};\n\nconst isBinaryOperator = chr => Object.keys(OPERATOR).filter(op => op.binary).includes(chr);\nconst isUnaryOperator = chr => Object.keys(OPERATOR).filter(op => !op.binary).includes(chr);\nconst stackify = arr => {\n\tarr = arr || [];\n\tarr.peek = () => arr[arr.length-1];\n\treturn arr;\n};\n\nconst makeTreeNode = (op, a, b) => {\n\treturn {\n\t\tvalue: op,\n\t\tchildren: [a, b]\n\t}\n};\n\nconst parseExpression = exp => {\n\tconst operator_stack = stackify();\n\tconst operand_stack = stackify();\n\n\tlet unique_tokens = [];\n\n    let token = '';\n\tlet unaryOp = 0;\n\tconst pushToken = () => {\n        operand_stack.push(token);\n        aggregateUnaryOp();\n\t\tif( !unique_tokens.includes(token) ) unique_tokens.push(token);\n\t\ttoken = '';\n    };\n    \n    const aggregateUnaryOp = () => {\n        while( unaryOp > 0 ) {\n            let op = operator_stack.pop();\n            let operand = operand_stack.pop();\n            operand_stack.push({\n                value: op,\n                children: [operand]\n            });\n            unaryOp--;\n        }\n    };\n\n\tlet grabbingExpression = false;\n\tlet expression = '';\n\tlet expParen = 0;\n\tfor( let char of exp ) {\n\t\t// first check if grabbing expression\n\t\tif( grabbingExpression ) {\n\t\t\tif( char === '(' ) {\n\t\t\t\texpParen++;\n\t\t\t\texpression += '(';\n\t\t\t} else if( char === ')' ) {\n\t\t\t\texpParen--;\n\t\t\t\tif( expParen === 0 ) {\n\t\t\t\t\tlet exp = parseExpression(expression);\n                    let exp_tk = exp.tokens;\n                    for( let token of exp_tk ) {\n                        if( !unique_tokens.includes(token) ) unique_tokens.push(token);\n                    }\n                    delete exp.tokens; // remove extraneous data from internal tree nodes\n                    operand_stack.push(exp);\n                    aggregateUnaryOp();\n\t\t\t\t\texpression = '';\n\t\t\t\t\tgrabbingExpression = false;\n\t\t\t\t} else {\n\t\t\t\t\texpression += ')';\n\t\t\t\t}\n\t\t\t} else expression += char;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif( /\\s/.test(char) ) {\n\t\t\tif( token !== '' ) pushToken();\n\t\t} else if( /[a-zA-Z0-9_]/.test(char) ) {\n\t\t\ttoken += char;\n\t\t} else {\n\t\t\tif( token !== '' ) pushToken();\n\t\t\tif( isBinaryOperator(char) ) {\n\t\t\t\tif( operator_stack.length > 0 && OPERATOR[char].precedence < OPERATOR[operator_stack.peek()].precedence ) {\n\t\t\t\t\tconst op1 = operand_stack.pop();\n\t\t\t\t\tconst op2 = operand_stack.pop();\n\t\t\t\t\tconst op = operator_stack.pop();\n\t\t\t\t\toperand_stack.push(makeTreeNode(op, op1, op2));\n\t\t\t\t}\n\t\t\t\toperator_stack.push(char);\n\t\t\t} else if( isUnaryOperator(char) ) {\n                unaryOp++;\n                operator_stack.push(char);\n            }else if( char === '(' ) {\n\t\t\t\tgrabbingExpression = true;\n\t\t\t\texpParen++;\n\t\t\t} else {\n\t\t\t\tthrow new Error(`Unexpected character '${char}'`);\n\t\t\t}\n\t\t}\n\t}\n\n\tif( grabbingExpression ) {\n\t\tthrow new Error('Expression contains unmatched opening parenthesis.');\n\t}\n\n\tif( token !== '' ) pushToken();\n\n\twhile(operator_stack.length > 0) {\n\t\tlet op1 = operand_stack.pop();\n\t\tlet op2 = operand_stack.pop();\n\t\tlet op = operator_stack.pop();\n\t\toperand_stack.push(makeTreeNode(op, op1, op2));\n\t}\n\tif( operand_stack.length > 1 ) {\n\t\tthrow new Error('Too many operands!');\n    }\n\n    let retObj = operand_stack[0];\n    if( typeof retObj === 'string' ) {\n        retObj = {\n            value: retObj,\n            children: []\n        };\n    }\n\tretObj.tokens = unique_tokens;\n\n\treturn operand_stack[0]; // should be the expression tree (or a single-token string)\n};\n\nfunction evaluateTree(treeHead, values) {\n\tvalues[true] = true;\n\tvalues[false] = false;\n\n\tif( typeof treeHead === 'string' ) {\n\t\tif( treeHead[0] === '~' ) {\n\t\t\treturn !values[treeHead[0].substring(1)]\n\t\t} else {\n\t\t\treturn values[treeHead[0]];\n\t\t}\n\t}\n\n\tlet maybeInvert = (val) => (treeHead.invert ? !val : val);\n\n\tlet op = treeHead.value;\n\tlet op1 = treeHead.children[0];\n\tlet op2 = treeHead.children[1];\n\n\tlet operand1;\n\tlet operand2;\n\tif( typeof op1 === 'object' ) {\n\t\toperand1 = evaluateTree(op1, values);\n\t}\n\tif( typeof op2 === 'object' ) {\n\t\toperand2 = evaluateTree(op2, values);\n\t}\n\n\tif( typeof op1 === \"string\" ) {\n\t\tif( op1[0] === '~' ) {\n\t\t\toperand1 = !values[op1.substring(1)];\n\t\t} else {\n\t\t\toperand1 = values[op1];\n\t\t}\n\t}\n\tif( typeof op2 === \"string\" ) {\n\t\tif( op2[0] === '~' ) {\n\t\t\toperand2 = !values[op2.substring(1)];\n\t\t} else {\n\t\t\toperand2 = values[op2];\n\t\t}\n\t}\n\n\treturn maybeInvert(OPERATOR[op].fn(operand1, operand2));\n};\n\nexport { parseExpression, evaluateTree };"
      ]
    },
    "sourceType": "module",
    "mtime": 1591211015498
  },
  "{\"sourceRoot\":\"/home/isaac/Personal/parsers/\",\"caller\":{\"name\":\"@babel/node\"},\"cwd\":\"/home/isaac/Personal/parsers\",\"filename\":\"/home/isaac/Personal/parsers/boolexp.js\",\"babelrc\":false,\"configFile\":false,\"passPerPreset\":false,\"envName\":\"development\",\"root\":\"/home/isaac/Personal/parsers\",\"plugins\":[{\"key\":\"proposal-nullish-coalescing-operator\",\"visitor\":{\"_exploded\":{},\"_verified\":{},\"LogicalExpression\":{\"enter\":[null]}},\"options\":{\"spec\":false,\"loose\":false,\"useBuiltIns\":false}},{\"key\":\"proposal-optional-chaining\",\"visitor\":{\"_exploded\":{},\"_verified\":{},\"OptionalCallExpression\":{\"enter\":[null]},\"OptionalMemberExpression\":{\"enter\":[null]}},\"options\":{\"spec\":false,\"loose\":false,\"useBuiltIns\":false}},{\"key\":\"proposal-json-strings\",\"visitor\":{\"_exploded\":{},\"_verified\":{},\"DirectiveLiteral\":{\"enter\":[null]},\"StringLiteral\":{\"enter\":[null]}},\"options\":{\"spec\":false,\"loose\":false,\"useBuiltIns\":false}},{\"key\":\"proposal-optional-catch-binding\",\"visitor\":{\"_exploded\":{},\"_verified\":{},\"CatchClause\":{\"enter\":[null]}},\"options\":{\"spec\":false,\"loose\":false,\"useBuiltIns\":false}},{\"key\":\"transform-parameters\",\"visitor\":{\"_exploded\":true,\"_verified\":true,\"FunctionDeclaration\":{\"enter\":[null]},\"FunctionExpression\":{\"enter\":[null]},\"ObjectMethod\":{\"enter\":[null]},\"ArrowFunctionExpression\":{\"enter\":[null]},\"ClassMethod\":{\"enter\":[null]},\"ClassPrivateMethod\":{\"enter\":[null]}},\"options\":{\"spec\":false,\"loose\":false,\"useBuiltIns\":false}},{\"key\":\"proposal-async-generator-functions\",\"visitor\":{\"_exploded\":{},\"_verified\":{},\"Program\":{\"enter\":[null]}},\"options\":{\"spec\":false,\"loose\":false,\"useBuiltIns\":false}},{\"key\":\"proposal-object-rest-spread\",\"visitor\":{\"_exploded\":{},\"_verified\":{},\"VariableDeclarator\":{\"enter\":[null]},\"ExportNamedDeclaration\":{\"enter\":[null]},\"CatchClause\":{\"enter\":[null]},\"AssignmentExpression\":{\"enter\":[null]},\"ArrayPattern\":{\"enter\":[null]},\"ObjectExpression\":{\"enter\":[null]},\"FunctionDeclaration\":{\"enter\":[null]},\"FunctionExpression\":{\"enter\":[null]},\"ObjectMethod\":{\"enter\":[null]},\"ArrowFunctionExpression\":{\"enter\":[null]},\"ClassMethod\":{\"enter\":[null]},\"ClassPrivateMethod\":{\"enter\":[null]},\"ForInStatement\":{\"enter\":[null]},\"ForOfStatement\":{\"enter\":[null]}},\"options\":{\"spec\":false,\"loose\":false,\"useBuiltIns\":false}},{\"key\":\"transform-dotall-regex\",\"visitor\":{\"RegExpLiteral\":{\"enter\":[null]},\"_exploded\":true,\"_verified\":true},\"options\":{\"spec\":false,\"loose\":false,\"useBuiltIns\":false}},{\"key\":\"proposal-unicode-property-regex\",\"visitor\":{\"RegExpLiteral\":{\"enter\":[null]},\"_exploded\":true,\"_verified\":true},\"options\":{\"spec\":false,\"loose\":false,\"useBuiltIns\":false}},{\"key\":\"transform-named-capturing-groups-regex\",\"visitor\":{\"RegExpLiteral\":{\"enter\":[null]},\"_exploded\":true,\"_verified\":true},\"options\":{\"spec\":false,\"loose\":false,\"useBuiltIns\":false}},{\"key\":\"transform-async-to-generator\",\"visitor\":{\"_exploded\":true,\"_verified\":true,\"FunctionDeclaration\":{\"enter\":[null]},\"FunctionExpression\":{\"enter\":[null]},\"ObjectMethod\":{\"enter\":[null]},\"ArrowFunctionExpression\":{\"enter\":[null]},\"ClassMethod\":{\"enter\":[null]},\"ClassPrivateMethod\":{\"enter\":[null]}},\"options\":{\"spec\":false,\"loose\":false,\"useBuiltIns\":false}},{\"key\":\"transform-exponentiation-operator\",\"visitor\":{\"AssignmentExpression\":{\"enter\":[null]},\"BinaryExpression\":{\"enter\":[null]},\"_exploded\":true,\"_verified\":true},\"options\":{\"spec\":false,\"loose\":false,\"useBuiltIns\":false}},{\"key\":\"transform-template-literals\",\"visitor\":{\"TaggedTemplateExpression\":{\"enter\":[null]},\"TemplateLiteral\":{\"enter\":[null]},\"_exploded\":true,\"_verified\":true},\"options\":{\"spec\":false,\"loose\":false,\"useBuiltIns\":false}},{\"key\":\"transform-literals\",\"visitor\":{\"NumericLiteral\":{\"enter\":[null]},\"StringLiteral\":{\"enter\":[null]},\"_exploded\":true,\"_verified\":true},\"options\":{\"spec\":false,\"loose\":false,\"useBuiltIns\":false}},{\"key\":\"transform-function-name\",\"visitor\":{\"FunctionExpression\":{\"exit\":[null]},\"ObjectProperty\":{\"enter\":[null]},\"_exploded\":true,\"_verified\":true},\"options\":{\"spec\":false,\"loose\":false,\"useBuiltIns\":false}},{\"key\":\"transform-arrow-functions\",\"visitor\":{\"ArrowFunctionExpression\":{\"enter\":[null]},\"_exploded\":true,\"_verified\":true},\"options\":{\"spec\":false,\"loose\":false,\"useBuiltIns\":false}},{\"key\":\"transform-block-scoped-functions\",\"visitor\":{\"BlockStatement\":{\"enter\":[null]},\"SwitchCase\":{\"enter\":[null]},\"_exploded\":true,\"_verified\":true},\"options\":{\"spec\":false,\"loose\":false,\"useBuiltIns\":false}},{\"key\":\"transform-classes\",\"visitor\":{\"ExportDefaultDeclaration\":{\"enter\":[null]},\"ClassDeclaration\":{\"enter\":[null]},\"ClassExpression\":{\"enter\":[null]},\"_exploded\":true,\"_verified\":true},\"options\":{\"spec\":false,\"loose\":false,\"useBuiltIns\":false}},{\"key\":\"transform-object-super\",\"visitor\":{\"ObjectExpression\":{\"enter\":[null]},\"_exploded\":true,\"_verified\":true},\"options\":{\"spec\":false,\"loose\":false,\"useBuiltIns\":false}},{\"key\":\"transform-shorthand-properties\",\"visitor\":{\"ObjectMethod\":{\"enter\":[null]},\"ObjectProperty\":{\"enter\":[null]},\"_exploded\":true,\"_verified\":true},\"options\":{\"spec\":false,\"loose\":false,\"useBuiltIns\":false}},{\"key\":\"transform-duplicate-keys\",\"visitor\":{\"ObjectExpression\":{\"enter\":[null]},\"_exploded\":true,\"_verified\":true},\"options\":{\"spec\":false,\"loose\":false,\"useBuiltIns\":false}},{\"key\":\"transform-computed-properties\",\"visitor\":{\"ObjectExpression\":{\"exit\":[null]},\"_exploded\":true,\"_verified\":true},\"options\":{\"spec\":false,\"loose\":false,\"useBuiltIns\":false}},{\"key\":\"transform-for-of\",\"visitor\":{\"ForOfStatement\":{\"enter\":[null]},\"_exploded\":true,\"_verified\":true},\"options\":{\"spec\":false,\"loose\":false,\"useBuiltIns\":false}},{\"key\":\"transform-sticky-regex\",\"visitor\":{\"RegExpLiteral\":{\"enter\":[null]},\"_exploded\":true,\"_verified\":true},\"options\":{\"spec\":false,\"loose\":false,\"useBuiltIns\":false}},{\"key\":\"transform-unicode-escapes\",\"visitor\":{\"Identifier\":{\"enter\":[null]},\"TemplateElement\":{\"enter\":[null]},\"_exploded\":true,\"StringLiteral\":{\"enter\":[null]},\"DirectiveLiteral\":{\"enter\":[null]},\"_verified\":true},\"options\":{\"spec\":false,\"loose\":false,\"useBuiltIns\":false}},{\"key\":\"transform-unicode-regex\",\"visitor\":{\"RegExpLiteral\":{\"enter\":[null]},\"_exploded\":true,\"_verified\":true},\"options\":{\"spec\":false,\"loose\":false,\"useBuiltIns\":false}},{\"key\":\"transform-spread\",\"visitor\":{\"ArrayExpression\":{\"enter\":[null]},\"CallExpression\":{\"enter\":[null]},\"NewExpression\":{\"enter\":[null]},\"_exploded\":true,\"_verified\":true},\"options\":{\"spec\":false,\"loose\":false,\"useBuiltIns\":false}},{\"key\":\"transform-destructuring\",\"visitor\":{\"ExportNamedDeclaration\":{\"enter\":[null]},\"CatchClause\":{\"enter\":[null]},\"AssignmentExpression\":{\"enter\":[null]},\"VariableDeclaration\":{\"enter\":[null]},\"_exploded\":true,\"_verified\":true,\"ForInStatement\":{\"enter\":[null]},\"ForOfStatement\":{\"enter\":[null]}},\"options\":{\"spec\":false,\"loose\":false,\"useBuiltIns\":false}},{\"key\":\"transform-block-scoping\",\"visitor\":{\"VariableDeclaration\":{\"enter\":[null]},\"CatchClause\":{\"enter\":[null]},\"_exploded\":true,\"BlockStatement\":{\"enter\":[null]},\"SwitchStatement\":{\"enter\":[null]},\"Program\":{\"enter\":[null]},\"_verified\":true,\"DoWhileStatement\":{\"enter\":[null]},\"ForInStatement\":{\"enter\":[null]},\"ForStatement\":{\"enter\":[null]},\"WhileStatement\":{\"enter\":[null]},\"ForOfStatement\":{\"enter\":[null]}},\"options\":{\"spec\":false,\"loose\":false,\"useBuiltIns\":false}},{\"key\":\"transform-typeof-symbol\",\"visitor\":{\"UnaryExpression\":{\"enter\":[null]},\"_exploded\":true,\"_verified\":true,\"BlockStatement\":{\"enter\":[null]},\"CatchClause\":{\"enter\":[null]},\"DoWhileStatement\":{\"enter\":[null]},\"ForInStatement\":{\"enter\":[null]},\"ForStatement\":{\"enter\":[null]},\"FunctionDeclaration\":{\"enter\":[null]},\"FunctionExpression\":{\"enter\":[null]},\"Program\":{\"enter\":[null]},\"ObjectMethod\":{\"enter\":[null]},\"SwitchStatement\":{\"enter\":[null]},\"WhileStatement\":{\"enter\":[null]},\"ArrowFunctionExpression\":{\"enter\":[null]},\"ClassExpression\":{\"enter\":[null]},\"ClassDeclaration\":{\"enter\":[null]},\"ForOfStatement\":{\"enter\":[null]},\"ClassMethod\":{\"enter\":[null]},\"ClassPrivateMethod\":{\"enter\":[null]},\"TSModuleBlock\":{\"enter\":[null]},\"AssignmentPattern\":{\"enter\":[null]},\"ArrayPattern\":{\"enter\":[null]},\"ObjectPattern\":{\"enter\":[null]}},\"options\":{\"spec\":false,\"loose\":false,\"useBuiltIns\":false}},{\"key\":\"transform-new-target\",\"visitor\":{\"MetaProperty\":{\"enter\":[null]},\"_exploded\":true,\"_verified\":true},\"options\":{\"spec\":false,\"loose\":false,\"useBuiltIns\":false}},{\"key\":\"regenerator-transform\",\"visitor\":{\"_exploded\":true,\"_verified\":true,\"ObjectMethod\":{\"enter\":[null],\"exit\":[null]},\"ClassMethod\":{\"enter\":[null],\"exit\":[null]},\"ClassPrivateMethod\":{\"enter\":[null],\"exit\":[null]},\"FunctionDeclaration\":{\"exit\":[null]},\"FunctionExpression\":{\"exit\":[null]},\"ArrowFunctionExpression\":{\"exit\":[null]}},\"options\":{\"spec\":false,\"loose\":false,\"useBuiltIns\":false}},{\"key\":\"transform-member-expression-literals\",\"visitor\":{\"MemberExpression\":{\"exit\":[null]},\"_exploded\":true,\"_verified\":true},\"options\":{\"spec\":false,\"loose\":false,\"useBuiltIns\":false}},{\"key\":\"transform-property-literals\",\"visitor\":{\"ObjectProperty\":{\"exit\":[null]},\"_exploded\":true,\"_verified\":true},\"options\":{\"spec\":false,\"loose\":false,\"useBuiltIns\":false}},{\"key\":\"transform-reserved-words\",\"visitor\":{\"_exploded\":true,\"_verified\":true,\"Identifier\":{\"enter\":[null,null]},\"JSXIdentifier\":{\"enter\":[null]}},\"options\":{\"spec\":false,\"loose\":false,\"useBuiltIns\":false}},{\"key\":\"transform-modules-commonjs\",\"visitor\":{\"CallExpression\":{\"enter\":[null]},\"Program\":{\"exit\":[null]},\"_exploded\":true,\"_verified\":true},\"options\":{\"spec\":false,\"loose\":false,\"useBuiltIns\":false}},{\"key\":\"proposal-dynamic-import\",\"visitor\":{\"_exploded\":{},\"_verified\":{},\"Program\":{\"enter\":[null]}},\"options\":{\"spec\":false,\"loose\":false,\"useBuiltIns\":false}}],\"presets\":[]}:7.10.2": {
    "metadata": {},
    "options": {
      "sourceRoot": "/home/isaac/Personal/parsers/",
      "caller": {
        "name": "@babel/node"
      },
      "cwd": "/home/isaac/Personal/parsers",
      "filename": "/home/isaac/Personal/parsers/boolexp.js",
      "babelrc": false,
      "configFile": false,
      "envName": "development",
      "root": "/home/isaac/Personal/parsers",
      "sourceMaps": "both",
      "ast": false,
      "passPerPreset": false,
      "plugins": [
        {
          "key": "proposal-nullish-coalescing-operator",
          "visitor": {
            "_exploded": {},
            "_verified": {},
            "LogicalExpression": {
              "enter": [
                null
              ]
            }
          },
          "options": {
            "spec": false,
            "loose": false,
            "useBuiltIns": false
          }
        },
        {
          "key": "proposal-optional-chaining",
          "visitor": {
            "_exploded": {},
            "_verified": {},
            "OptionalCallExpression": {
              "enter": [
                null
              ]
            },
            "OptionalMemberExpression": {
              "enter": [
                null
              ]
            }
          },
          "options": {
            "spec": false,
            "loose": false,
            "useBuiltIns": false
          }
        },
        {
          "key": "proposal-json-strings",
          "visitor": {
            "_exploded": {},
            "_verified": {},
            "DirectiveLiteral": {
              "enter": [
                null
              ]
            },
            "StringLiteral": {
              "enter": [
                null
              ]
            }
          },
          "options": {
            "spec": false,
            "loose": false,
            "useBuiltIns": false
          }
        },
        {
          "key": "proposal-optional-catch-binding",
          "visitor": {
            "_exploded": {},
            "_verified": {},
            "CatchClause": {
              "enter": [
                null
              ]
            }
          },
          "options": {
            "spec": false,
            "loose": false,
            "useBuiltIns": false
          }
        },
        {
          "key": "transform-parameters",
          "visitor": {
            "_exploded": true,
            "_verified": true,
            "FunctionDeclaration": {
              "enter": [
                null
              ]
            },
            "FunctionExpression": {
              "enter": [
                null
              ]
            },
            "ObjectMethod": {
              "enter": [
                null
              ]
            },
            "ArrowFunctionExpression": {
              "enter": [
                null
              ]
            },
            "ClassMethod": {
              "enter": [
                null
              ]
            },
            "ClassPrivateMethod": {
              "enter": [
                null
              ]
            }
          },
          "options": {
            "spec": false,
            "loose": false,
            "useBuiltIns": false
          }
        },
        {
          "key": "proposal-async-generator-functions",
          "visitor": {
            "_exploded": {},
            "_verified": {},
            "Program": {
              "enter": [
                null
              ]
            }
          },
          "options": {
            "spec": false,
            "loose": false,
            "useBuiltIns": false
          }
        },
        {
          "key": "proposal-object-rest-spread",
          "visitor": {
            "_exploded": {},
            "_verified": {},
            "VariableDeclarator": {
              "enter": [
                null
              ]
            },
            "ExportNamedDeclaration": {
              "enter": [
                null
              ]
            },
            "CatchClause": {
              "enter": [
                null
              ]
            },
            "AssignmentExpression": {
              "enter": [
                null
              ]
            },
            "ArrayPattern": {
              "enter": [
                null
              ]
            },
            "ObjectExpression": {
              "enter": [
                null
              ]
            },
            "FunctionDeclaration": {
              "enter": [
                null
              ]
            },
            "FunctionExpression": {
              "enter": [
                null
              ]
            },
            "ObjectMethod": {
              "enter": [
                null
              ]
            },
            "ArrowFunctionExpression": {
              "enter": [
                null
              ]
            },
            "ClassMethod": {
              "enter": [
                null
              ]
            },
            "ClassPrivateMethod": {
              "enter": [
                null
              ]
            },
            "ForInStatement": {
              "enter": [
                null
              ]
            },
            "ForOfStatement": {
              "enter": [
                null
              ]
            }
          },
          "options": {
            "spec": false,
            "loose": false,
            "useBuiltIns": false
          }
        },
        {
          "key": "transform-dotall-regex",
          "visitor": {
            "RegExpLiteral": {
              "enter": [
                null
              ]
            },
            "_exploded": true,
            "_verified": true
          },
          "options": {
            "spec": false,
            "loose": false,
            "useBuiltIns": false
          }
        },
        {
          "key": "proposal-unicode-property-regex",
          "visitor": {
            "RegExpLiteral": {
              "enter": [
                null
              ]
            },
            "_exploded": true,
            "_verified": true
          },
          "options": {
            "spec": false,
            "loose": false,
            "useBuiltIns": false
          }
        },
        {
          "key": "transform-named-capturing-groups-regex",
          "visitor": {
            "RegExpLiteral": {
              "enter": [
                null
              ]
            },
            "_exploded": true,
            "_verified": true
          },
          "options": {
            "spec": false,
            "loose": false,
            "useBuiltIns": false
          }
        },
        {
          "key": "transform-async-to-generator",
          "visitor": {
            "_exploded": true,
            "_verified": true,
            "FunctionDeclaration": {
              "enter": [
                null
              ]
            },
            "FunctionExpression": {
              "enter": [
                null
              ]
            },
            "ObjectMethod": {
              "enter": [
                null
              ]
            },
            "ArrowFunctionExpression": {
              "enter": [
                null
              ]
            },
            "ClassMethod": {
              "enter": [
                null
              ]
            },
            "ClassPrivateMethod": {
              "enter": [
                null
              ]
            }
          },
          "options": {
            "spec": false,
            "loose": false,
            "useBuiltIns": false
          }
        },
        {
          "key": "transform-exponentiation-operator",
          "visitor": {
            "AssignmentExpression": {
              "enter": [
                null
              ]
            },
            "BinaryExpression": {
              "enter": [
                null
              ]
            },
            "_exploded": true,
            "_verified": true
          },
          "options": {
            "spec": false,
            "loose": false,
            "useBuiltIns": false
          }
        },
        {
          "key": "transform-template-literals",
          "visitor": {
            "TaggedTemplateExpression": {
              "enter": [
                null
              ]
            },
            "TemplateLiteral": {
              "enter": [
                null
              ]
            },
            "_exploded": true,
            "_verified": true
          },
          "options": {
            "spec": false,
            "loose": false,
            "useBuiltIns": false
          }
        },
        {
          "key": "transform-literals",
          "visitor": {
            "NumericLiteral": {
              "enter": [
                null
              ]
            },
            "StringLiteral": {
              "enter": [
                null
              ]
            },
            "_exploded": true,
            "_verified": true
          },
          "options": {
            "spec": false,
            "loose": false,
            "useBuiltIns": false
          }
        },
        {
          "key": "transform-function-name",
          "visitor": {
            "FunctionExpression": {
              "exit": [
                null
              ]
            },
            "ObjectProperty": {
              "enter": [
                null
              ]
            },
            "_exploded": true,
            "_verified": true
          },
          "options": {
            "spec": false,
            "loose": false,
            "useBuiltIns": false
          }
        },
        {
          "key": "transform-arrow-functions",
          "visitor": {
            "ArrowFunctionExpression": {
              "enter": [
                null
              ]
            },
            "_exploded": true,
            "_verified": true
          },
          "options": {
            "spec": false,
            "loose": false,
            "useBuiltIns": false
          }
        },
        {
          "key": "transform-block-scoped-functions",
          "visitor": {
            "BlockStatement": {
              "enter": [
                null
              ]
            },
            "SwitchCase": {
              "enter": [
                null
              ]
            },
            "_exploded": true,
            "_verified": true
          },
          "options": {
            "spec": false,
            "loose": false,
            "useBuiltIns": false
          }
        },
        {
          "key": "transform-classes",
          "visitor": {
            "ExportDefaultDeclaration": {
              "enter": [
                null
              ]
            },
            "ClassDeclaration": {
              "enter": [
                null
              ]
            },
            "ClassExpression": {
              "enter": [
                null
              ]
            },
            "_exploded": true,
            "_verified": true
          },
          "options": {
            "spec": false,
            "loose": false,
            "useBuiltIns": false
          }
        },
        {
          "key": "transform-object-super",
          "visitor": {
            "ObjectExpression": {
              "enter": [
                null
              ]
            },
            "_exploded": true,
            "_verified": true
          },
          "options": {
            "spec": false,
            "loose": false,
            "useBuiltIns": false
          }
        },
        {
          "key": "transform-shorthand-properties",
          "visitor": {
            "ObjectMethod": {
              "enter": [
                null
              ]
            },
            "ObjectProperty": {
              "enter": [
                null
              ]
            },
            "_exploded": true,
            "_verified": true
          },
          "options": {
            "spec": false,
            "loose": false,
            "useBuiltIns": false
          }
        },
        {
          "key": "transform-duplicate-keys",
          "visitor": {
            "ObjectExpression": {
              "enter": [
                null
              ]
            },
            "_exploded": true,
            "_verified": true
          },
          "options": {
            "spec": false,
            "loose": false,
            "useBuiltIns": false
          }
        },
        {
          "key": "transform-computed-properties",
          "visitor": {
            "ObjectExpression": {
              "exit": [
                null
              ]
            },
            "_exploded": true,
            "_verified": true
          },
          "options": {
            "spec": false,
            "loose": false,
            "useBuiltIns": false
          }
        },
        {
          "key": "transform-for-of",
          "visitor": {
            "ForOfStatement": {
              "enter": [
                null
              ]
            },
            "_exploded": true,
            "_verified": true
          },
          "options": {
            "spec": false,
            "loose": false,
            "useBuiltIns": false
          }
        },
        {
          "key": "transform-sticky-regex",
          "visitor": {
            "RegExpLiteral": {
              "enter": [
                null
              ]
            },
            "_exploded": true,
            "_verified": true
          },
          "options": {
            "spec": false,
            "loose": false,
            "useBuiltIns": false
          }
        },
        {
          "key": "transform-unicode-escapes",
          "visitor": {
            "Identifier": {
              "enter": [
                null
              ]
            },
            "TemplateElement": {
              "enter": [
                null
              ]
            },
            "_exploded": true,
            "StringLiteral": {
              "enter": [
                null
              ]
            },
            "DirectiveLiteral": {
              "enter": [
                null
              ]
            },
            "_verified": true
          },
          "options": {
            "spec": false,
            "loose": false,
            "useBuiltIns": false
          }
        },
        {
          "key": "transform-unicode-regex",
          "visitor": {
            "RegExpLiteral": {
              "enter": [
                null
              ]
            },
            "_exploded": true,
            "_verified": true
          },
          "options": {
            "spec": false,
            "loose": false,
            "useBuiltIns": false
          }
        },
        {
          "key": "transform-spread",
          "visitor": {
            "ArrayExpression": {
              "enter": [
                null
              ]
            },
            "CallExpression": {
              "enter": [
                null
              ]
            },
            "NewExpression": {
              "enter": [
                null
              ]
            },
            "_exploded": true,
            "_verified": true
          },
          "options": {
            "spec": false,
            "loose": false,
            "useBuiltIns": false
          }
        },
        {
          "key": "transform-destructuring",
          "visitor": {
            "ExportNamedDeclaration": {
              "enter": [
                null
              ]
            },
            "CatchClause": {
              "enter": [
                null
              ]
            },
            "AssignmentExpression": {
              "enter": [
                null
              ]
            },
            "VariableDeclaration": {
              "enter": [
                null
              ]
            },
            "_exploded": true,
            "_verified": true,
            "ForInStatement": {
              "enter": [
                null
              ]
            },
            "ForOfStatement": {
              "enter": [
                null
              ]
            }
          },
          "options": {
            "spec": false,
            "loose": false,
            "useBuiltIns": false
          }
        },
        {
          "key": "transform-block-scoping",
          "visitor": {
            "VariableDeclaration": {
              "enter": [
                null
              ]
            },
            "CatchClause": {
              "enter": [
                null
              ]
            },
            "_exploded": true,
            "BlockStatement": {
              "enter": [
                null
              ]
            },
            "SwitchStatement": {
              "enter": [
                null
              ]
            },
            "Program": {
              "enter": [
                null
              ]
            },
            "_verified": true,
            "DoWhileStatement": {
              "enter": [
                null
              ]
            },
            "ForInStatement": {
              "enter": [
                null
              ]
            },
            "ForStatement": {
              "enter": [
                null
              ]
            },
            "WhileStatement": {
              "enter": [
                null
              ]
            },
            "ForOfStatement": {
              "enter": [
                null
              ]
            }
          },
          "options": {
            "spec": false,
            "loose": false,
            "useBuiltIns": false
          }
        },
        {
          "key": "transform-typeof-symbol",
          "visitor": {
            "UnaryExpression": {
              "enter": [
                null
              ]
            },
            "_exploded": true,
            "_verified": true,
            "BlockStatement": {
              "enter": [
                null
              ]
            },
            "CatchClause": {
              "enter": [
                null
              ]
            },
            "DoWhileStatement": {
              "enter": [
                null
              ]
            },
            "ForInStatement": {
              "enter": [
                null
              ]
            },
            "ForStatement": {
              "enter": [
                null
              ]
            },
            "FunctionDeclaration": {
              "enter": [
                null
              ]
            },
            "FunctionExpression": {
              "enter": [
                null
              ]
            },
            "Program": {
              "enter": [
                null
              ]
            },
            "ObjectMethod": {
              "enter": [
                null
              ]
            },
            "SwitchStatement": {
              "enter": [
                null
              ]
            },
            "WhileStatement": {
              "enter": [
                null
              ]
            },
            "ArrowFunctionExpression": {
              "enter": [
                null
              ]
            },
            "ClassExpression": {
              "enter": [
                null
              ]
            },
            "ClassDeclaration": {
              "enter": [
                null
              ]
            },
            "ForOfStatement": {
              "enter": [
                null
              ]
            },
            "ClassMethod": {
              "enter": [
                null
              ]
            },
            "ClassPrivateMethod": {
              "enter": [
                null
              ]
            },
            "TSModuleBlock": {
              "enter": [
                null
              ]
            },
            "AssignmentPattern": {
              "enter": [
                null
              ]
            },
            "ArrayPattern": {
              "enter": [
                null
              ]
            },
            "ObjectPattern": {
              "enter": [
                null
              ]
            }
          },
          "options": {
            "spec": false,
            "loose": false,
            "useBuiltIns": false
          }
        },
        {
          "key": "transform-new-target",
          "visitor": {
            "MetaProperty": {
              "enter": [
                null
              ]
            },
            "_exploded": true,
            "_verified": true
          },
          "options": {
            "spec": false,
            "loose": false,
            "useBuiltIns": false
          }
        },
        {
          "key": "regenerator-transform",
          "visitor": {
            "_exploded": true,
            "_verified": true,
            "ObjectMethod": {
              "enter": [
                null
              ],
              "exit": [
                null
              ]
            },
            "ClassMethod": {
              "enter": [
                null
              ],
              "exit": [
                null
              ]
            },
            "ClassPrivateMethod": {
              "enter": [
                null
              ],
              "exit": [
                null
              ]
            },
            "FunctionDeclaration": {
              "exit": [
                null
              ]
            },
            "FunctionExpression": {
              "exit": [
                null
              ]
            },
            "ArrowFunctionExpression": {
              "exit": [
                null
              ]
            }
          },
          "options": {
            "spec": false,
            "loose": false,
            "useBuiltIns": false
          }
        },
        {
          "key": "transform-member-expression-literals",
          "visitor": {
            "MemberExpression": {
              "exit": [
                null
              ]
            },
            "_exploded": true,
            "_verified": true
          },
          "options": {
            "spec": false,
            "loose": false,
            "useBuiltIns": false
          }
        },
        {
          "key": "transform-property-literals",
          "visitor": {
            "ObjectProperty": {
              "exit": [
                null
              ]
            },
            "_exploded": true,
            "_verified": true
          },
          "options": {
            "spec": false,
            "loose": false,
            "useBuiltIns": false
          }
        },
        {
          "key": "transform-reserved-words",
          "visitor": {
            "_exploded": true,
            "_verified": true,
            "Identifier": {
              "enter": [
                null,
                null
              ]
            },
            "JSXIdentifier": {
              "enter": [
                null
              ]
            }
          },
          "options": {
            "spec": false,
            "loose": false,
            "useBuiltIns": false
          }
        },
        {
          "key": "transform-modules-commonjs",
          "visitor": {
            "CallExpression": {
              "enter": [
                null
              ]
            },
            "Program": {
              "exit": [
                null
              ]
            },
            "_exploded": true,
            "_verified": true
          },
          "options": {
            "spec": false,
            "loose": false,
            "useBuiltIns": false
          }
        },
        {
          "key": "proposal-dynamic-import",
          "visitor": {
            "_exploded": {},
            "_verified": {},
            "Program": {
              "enter": [
                null
              ]
            }
          },
          "options": {
            "spec": false,
            "loose": false,
            "useBuiltIns": false
          }
        }
      ],
      "presets": [],
      "parserOpts": {
        "sourceType": "module",
        "sourceFileName": "/home/isaac/Personal/parsers/boolexp.js",
        "plugins": [
          "nullishCoalescingOperator",
          "optionalChaining",
          "jsonStrings",
          "optionalCatchBinding",
          "asyncGenerators",
          "objectRestSpread",
          "dynamicImport"
        ]
      },
      "generatorOpts": {
        "filename": "/home/isaac/Personal/parsers/boolexp.js",
        "comments": true,
        "compact": "auto",
        "sourceMaps": "both",
        "sourceRoot": "/home/isaac/Personal/parsers/",
        "sourceFileName": "boolexp.js"
      }
    },
    "ast": null,
    "code": "\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\n// Boolean Expressions Parser/Evaluator\nvar OPERATOR = {\n  // operator precedence\n  '*': {\n    precedence: 2,\n    binary: true,\n    fn: function fn(a, b) {\n      return a && b;\n    }\n  },\n  '+': {\n    precedence: 1,\n    binary: true,\n    fn: function fn(a, b) {\n      return a || b;\n    }\n  },\n  '~': {\n    binary: false,\n    fn: function fn(a) {\n      return !a;\n    }\n  }\n};\n\nvar isOperator = function isOperator(chr) {\n  return Object.keys(OPERATOR).includes(chr);\n};\n\nvar isBinaryOperator = function isBinaryOperator(chr) {\n  return Object.keys(OPERATOR).filter(function (op) {\n    return OPERATOR[op].binary;\n  }).includes(chr);\n};\n\nvar isUnaryOperator = function isUnaryOperator(chr) {\n  return Object.keys(OPERATOR).filter(function (op) {\n    return !OPERATOR[op].binary;\n  }).includes(chr);\n};\n\nvar stackify = function stackify(arr) {\n  arr = arr || [];\n\n  arr.peek = function () {\n    return arr[arr.length - 1];\n  };\n\n  return arr;\n};\n\nvar format = function format(tk) {\n  return typeof tk === 'string' ? {\n    value: tk,\n    children: []\n  } : tk;\n};\n\nvar makeTreeNode = function makeTreeNode(op, a, b) {\n  return {\n    value: op,\n    children: [a, b]\n  };\n};\n\nvar parseExpression = function parseExpression(exp) {\n  var operator_stack = stackify();\n  var operand_stack = stackify();\n  var unique_tokens = [];\n  var token = '';\n  var unaryOp = 0;\n\n  var pushToken = function pushToken() {\n    operand_stack.push(token);\n    aggregateUnaryOp();\n    if (!unique_tokens.includes(token)) unique_tokens.push(token);\n    token = '';\n  };\n\n  var aggregateUnaryOp = function aggregateUnaryOp() {\n    while (unaryOp > 0) {\n      var op = operator_stack.pop();\n      var operand = operand_stack.pop();\n      operand_stack.push({\n        value: op,\n        children: [format(operand)]\n      });\n      unaryOp--;\n    }\n  };\n\n  var grabbingExpression = false;\n  var expression = '';\n  var expParen = 0;\n\n  var _iterator = _createForOfIteratorHelper(exp),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var _char = _step.value;\n\n      // first check if grabbing expression\n      if (grabbingExpression) {\n        if (_char === '(') {\n          expParen++;\n          expression += '(';\n        } else if (_char === ')') {\n          expParen--;\n\n          if (expParen === 0) {\n            var _exp = parseExpression(expression);\n\n            var exp_tk = _exp.tokens;\n\n            var _iterator2 = _createForOfIteratorHelper(exp_tk),\n                _step2;\n\n            try {\n              for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n                var _token = _step2.value;\n                if (!unique_tokens.includes(_token)) unique_tokens.push(_token);\n              }\n            } catch (err) {\n              _iterator2.e(err);\n            } finally {\n              _iterator2.f();\n            }\n\n            delete _exp.tokens; // remove extraneous data from internal tree nodes\n\n            operand_stack.push(_exp);\n            aggregateUnaryOp();\n            expression = '';\n            grabbingExpression = false;\n          } else {\n            expression += ')';\n          }\n        } else expression += _char;\n\n        continue;\n      }\n\n      if (/\\s/.test(_char)) {\n        if (token !== '') pushToken();\n      } else if (/[a-zA-Z0-9_]/.test(_char)) {\n        token += _char;\n      } else {\n        if (token !== '') pushToken();\n\n        if (isBinaryOperator(_char)) {\n          if (operator_stack.length > 0 && OPERATOR[_char].precedence < OPERATOR[operator_stack.peek()].precedence) {\n            var _op = operand_stack.pop();\n\n            var _op2 = operand_stack.pop();\n\n            var _op3 = operator_stack.pop();\n\n            operand_stack.push(makeTreeNode(_op3, _op, _op2));\n          }\n\n          operator_stack.push(_char);\n        } else if (isUnaryOperator(_char)) {\n          unaryOp++;\n          operator_stack.push(_char);\n        } else if (_char === '(') {\n          grabbingExpression = true;\n          expParen++;\n        } else {\n          throw new Error(\"Unexpected character '\".concat(_char, \"'\"));\n        }\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  if (grabbingExpression) {\n    throw new Error('Expression contains unmatched opening parenthesis.');\n  }\n\n  if (token !== '') pushToken();\n\n  while (operator_stack.length > 0) {\n    var op1 = format(operand_stack.pop());\n    var op2 = format(operand_stack.pop());\n    var op = operator_stack.pop();\n    operand_stack.push(makeTreeNode(op, op1, op2));\n  }\n\n  if (operand_stack.length > 1) {\n    throw new Error('Too many operands!');\n  }\n\n  var retObj = format(operand_stack[0]);\n  retObj.tokens = unique_tokens;\n  return operand_stack[0]; // should be the expression tree (or a single-token string)\n};\n\nvar Expression = /*#__PURE__*/function () {\n  function Expression(exp) {\n    _classCallCheck(this, Expression);\n\n    if (typeof exp !== 'string') {\n      throw new Error(\"Expression constructor takes in a boolean expression.\");\n    }\n\n    this.tree = parseExpression(exp);\n  }\n\n  _createClass(Expression, [{\n    key: \"getTokens\",\n    value: function getTokens() {\n      return this.tree.tokens;\n    }\n  }, {\n    key: \"evaluate\",\n    value: function evaluate(values) {\n      var _iterator3 = _createForOfIteratorHelper(this.tree.tokens),\n          _step3;\n\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var token = _step3.value;\n          if (!values.hasOwnProperty(token)) throw new Error(\"values must define a boolean value for every variable.\");\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n\n      return evaluateTree(this.tree, values);\n    }\n  }]);\n\n  return Expression;\n}();\n\nfunction evaluateTree(treeHead, values) {\n  var v = treeHead.value;\n\n  if (isOperator(v)) {\n    var children = treeHead.children.map(function (t) {\n      return evaluateTree(t, values);\n    });\n    var opfn = OPERATOR[v].fn;\n    return opfn.apply(void 0, _toConsumableArray(children));\n  } else {\n    return values[v];\n  }\n}\n\n;\nvar _default = Expression;\nexports[\"default\"] = _default;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImJvb2xleHAuanMiXSwibmFtZXMiOlsiT1BFUkFUT1IiLCJwcmVjZWRlbmNlIiwiYmluYXJ5IiwiZm4iLCJhIiwiYiIsImlzT3BlcmF0b3IiLCJjaHIiLCJPYmplY3QiLCJrZXlzIiwiaW5jbHVkZXMiLCJpc0JpbmFyeU9wZXJhdG9yIiwiZmlsdGVyIiwib3AiLCJpc1VuYXJ5T3BlcmF0b3IiLCJzdGFja2lmeSIsImFyciIsInBlZWsiLCJsZW5ndGgiLCJmb3JtYXQiLCJ0ayIsInZhbHVlIiwiY2hpbGRyZW4iLCJtYWtlVHJlZU5vZGUiLCJwYXJzZUV4cHJlc3Npb24iLCJleHAiLCJvcGVyYXRvcl9zdGFjayIsIm9wZXJhbmRfc3RhY2siLCJ1bmlxdWVfdG9rZW5zIiwidG9rZW4iLCJ1bmFyeU9wIiwicHVzaFRva2VuIiwicHVzaCIsImFnZ3JlZ2F0ZVVuYXJ5T3AiLCJwb3AiLCJvcGVyYW5kIiwiZ3JhYmJpbmdFeHByZXNzaW9uIiwiZXhwcmVzc2lvbiIsImV4cFBhcmVuIiwiY2hhciIsImV4cF90ayIsInRva2VucyIsInRlc3QiLCJvcDEiLCJvcDIiLCJFcnJvciIsInJldE9iaiIsIkV4cHJlc3Npb24iLCJ0cmVlIiwidmFsdWVzIiwiaGFzT3duUHJvcGVydHkiLCJldmFsdWF0ZVRyZWUiLCJ0cmVlSGVhZCIsInYiLCJtYXAiLCJ0Iiwib3BmbiJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFFQSxJQUFNQSxRQUFRLEdBQUc7QUFDaEI7QUFDQSxPQUFLO0FBQ0VDLElBQUFBLFVBQVUsRUFBRSxDQURkO0FBRUVDLElBQUFBLE1BQU0sRUFBRSxJQUZWO0FBR0pDLElBQUFBLEVBQUUsRUFBRSxZQUFDQyxDQUFELEVBQUlDLENBQUo7QUFBQSxhQUFVRCxDQUFDLElBQUlDLENBQWY7QUFBQTtBQUhBLEdBRlc7QUFPaEIsT0FBSztBQUNFSixJQUFBQSxVQUFVLEVBQUUsQ0FEZDtBQUVFQyxJQUFBQSxNQUFNLEVBQUUsSUFGVjtBQUdKQyxJQUFBQSxFQUFFLEVBQUUsWUFBQ0MsQ0FBRCxFQUFJQyxDQUFKO0FBQUEsYUFBVUQsQ0FBQyxJQUFJQyxDQUFmO0FBQUE7QUFIQSxHQVBXO0FBWWIsT0FBSztBQUNESCxJQUFBQSxNQUFNLEVBQUUsS0FEUDtBQUVEQyxJQUFBQSxFQUFFLEVBQUUsWUFBQUMsQ0FBQztBQUFBLGFBQUksQ0FBQ0EsQ0FBTDtBQUFBO0FBRko7QUFaUSxDQUFqQjs7QUFrQkEsSUFBTUUsVUFBVSxHQUFHLFNBQWJBLFVBQWEsQ0FBQUMsR0FBRztBQUFBLFNBQUlDLE1BQU0sQ0FBQ0MsSUFBUCxDQUFZVCxRQUFaLEVBQXNCVSxRQUF0QixDQUErQkgsR0FBL0IsQ0FBSjtBQUFBLENBQXRCOztBQUNBLElBQU1JLGdCQUFnQixHQUFHLFNBQW5CQSxnQkFBbUIsQ0FBQUosR0FBRztBQUFBLFNBQUlDLE1BQU0sQ0FBQ0MsSUFBUCxDQUFZVCxRQUFaLEVBQXNCWSxNQUF0QixDQUE2QixVQUFBQyxFQUFFO0FBQUEsV0FBSWIsUUFBUSxDQUFDYSxFQUFELENBQVIsQ0FBYVgsTUFBakI7QUFBQSxHQUEvQixFQUF3RFEsUUFBeEQsQ0FBaUVILEdBQWpFLENBQUo7QUFBQSxDQUE1Qjs7QUFDQSxJQUFNTyxlQUFlLEdBQUcsU0FBbEJBLGVBQWtCLENBQUFQLEdBQUc7QUFBQSxTQUFJQyxNQUFNLENBQUNDLElBQVAsQ0FBWVQsUUFBWixFQUFzQlksTUFBdEIsQ0FBNkIsVUFBQUMsRUFBRTtBQUFBLFdBQUksQ0FBQ2IsUUFBUSxDQUFDYSxFQUFELENBQVIsQ0FBYVgsTUFBbEI7QUFBQSxHQUEvQixFQUF5RFEsUUFBekQsQ0FBa0VILEdBQWxFLENBQUo7QUFBQSxDQUEzQjs7QUFDQSxJQUFNUSxRQUFRLEdBQUcsU0FBWEEsUUFBVyxDQUFBQyxHQUFHLEVBQUk7QUFDdkJBLEVBQUFBLEdBQUcsR0FBR0EsR0FBRyxJQUFJLEVBQWI7O0FBQ0FBLEVBQUFBLEdBQUcsQ0FBQ0MsSUFBSixHQUFXO0FBQUEsV0FBTUQsR0FBRyxDQUFDQSxHQUFHLENBQUNFLE1BQUosR0FBVyxDQUFaLENBQVQ7QUFBQSxHQUFYOztBQUNBLFNBQU9GLEdBQVA7QUFDQSxDQUpEOztBQU1BLElBQU1HLE1BQU0sR0FBRyxTQUFUQSxNQUFTLENBQUNDLEVBQUQ7QUFBQSxTQUFRLE9BQU9BLEVBQVAsS0FBYyxRQUFkLEdBQXlCO0FBQUVDLElBQUFBLEtBQUssRUFBRUQsRUFBVDtBQUFhRSxJQUFBQSxRQUFRLEVBQUU7QUFBdkIsR0FBekIsR0FBdURGLEVBQS9EO0FBQUEsQ0FBZjs7QUFFQSxJQUFNRyxZQUFZLEdBQUcsU0FBZkEsWUFBZSxDQUFDVixFQUFELEVBQUtULENBQUwsRUFBUUMsQ0FBUixFQUFjO0FBQ2xDLFNBQU87QUFDTmdCLElBQUFBLEtBQUssRUFBRVIsRUFERDtBQUVOUyxJQUFBQSxRQUFRLEVBQUUsQ0FBQ2xCLENBQUQsRUFBSUMsQ0FBSjtBQUZKLEdBQVA7QUFJQSxDQUxEOztBQU9BLElBQU1tQixlQUFlLEdBQUcsU0FBbEJBLGVBQWtCLENBQUFDLEdBQUcsRUFBSTtBQUM5QixNQUFNQyxjQUFjLEdBQUdYLFFBQVEsRUFBL0I7QUFDQSxNQUFNWSxhQUFhLEdBQUdaLFFBQVEsRUFBOUI7QUFFQSxNQUFJYSxhQUFhLEdBQUcsRUFBcEI7QUFFRyxNQUFJQyxLQUFLLEdBQUcsRUFBWjtBQUNILE1BQUlDLE9BQU8sR0FBRyxDQUFkOztBQUNBLE1BQU1DLFNBQVMsR0FBRyxTQUFaQSxTQUFZLEdBQU07QUFDakJKLElBQUFBLGFBQWEsQ0FBQ0ssSUFBZCxDQUFtQkgsS0FBbkI7QUFDQUksSUFBQUEsZ0JBQWdCO0FBQ3RCLFFBQUksQ0FBQ0wsYUFBYSxDQUFDbEIsUUFBZCxDQUF1Qm1CLEtBQXZCLENBQUwsRUFBcUNELGFBQWEsQ0FBQ0ksSUFBZCxDQUFtQkgsS0FBbkI7QUFDckNBLElBQUFBLEtBQUssR0FBRyxFQUFSO0FBQ0csR0FMSjs7QUFPRyxNQUFNSSxnQkFBZ0IsR0FBRyxTQUFuQkEsZ0JBQW1CLEdBQU07QUFDM0IsV0FBT0gsT0FBTyxHQUFHLENBQWpCLEVBQXFCO0FBQ2pCLFVBQUlqQixFQUFFLEdBQUdhLGNBQWMsQ0FBQ1EsR0FBZixFQUFUO0FBQ0EsVUFBSUMsT0FBTyxHQUFHUixhQUFhLENBQUNPLEdBQWQsRUFBZDtBQUNBUCxNQUFBQSxhQUFhLENBQUNLLElBQWQsQ0FBbUI7QUFDZlgsUUFBQUEsS0FBSyxFQUFFUixFQURRO0FBRWZTLFFBQUFBLFFBQVEsRUFBRSxDQUFDSCxNQUFNLENBQUNnQixPQUFELENBQVA7QUFGSyxPQUFuQjtBQUlBTCxNQUFBQSxPQUFPO0FBQ1Y7QUFDSixHQVZEOztBQVlILE1BQUlNLGtCQUFrQixHQUFHLEtBQXpCO0FBQ0EsTUFBSUMsVUFBVSxHQUFHLEVBQWpCO0FBQ0EsTUFBSUMsUUFBUSxHQUFHLENBQWY7O0FBN0I4Qiw2Q0E4QmJiLEdBOUJhO0FBQUE7O0FBQUE7QUE4QjlCLHdEQUF1QjtBQUFBLFVBQWRjLEtBQWM7O0FBQ3RCO0FBQ0EsVUFBSUgsa0JBQUosRUFBeUI7QUFDeEIsWUFBSUcsS0FBSSxLQUFLLEdBQWIsRUFBbUI7QUFDbEJELFVBQUFBLFFBQVE7QUFDUkQsVUFBQUEsVUFBVSxJQUFJLEdBQWQ7QUFDQSxTQUhELE1BR08sSUFBSUUsS0FBSSxLQUFLLEdBQWIsRUFBbUI7QUFDekJELFVBQUFBLFFBQVE7O0FBQ1IsY0FBSUEsUUFBUSxLQUFLLENBQWpCLEVBQXFCO0FBQ3BCLGdCQUFJYixJQUFHLEdBQUdELGVBQWUsQ0FBQ2EsVUFBRCxDQUF6Qjs7QUFDZSxnQkFBSUcsTUFBTSxHQUFHZixJQUFHLENBQUNnQixNQUFqQjs7QUFGSyx3REFHYUQsTUFIYjtBQUFBOztBQUFBO0FBR0wscUVBQTJCO0FBQUEsb0JBQWxCWCxNQUFrQjtBQUN2QixvQkFBSSxDQUFDRCxhQUFhLENBQUNsQixRQUFkLENBQXVCbUIsTUFBdkIsQ0FBTCxFQUFxQ0QsYUFBYSxDQUFDSSxJQUFkLENBQW1CSCxNQUFuQjtBQUN4QztBQUxJO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBTUwsbUJBQU9KLElBQUcsQ0FBQ2dCLE1BQVgsQ0FOSyxDQU1jOztBQUNuQmQsWUFBQUEsYUFBYSxDQUFDSyxJQUFkLENBQW1CUCxJQUFuQjtBQUNBUSxZQUFBQSxnQkFBZ0I7QUFDL0JJLFlBQUFBLFVBQVUsR0FBRyxFQUFiO0FBQ0FELFlBQUFBLGtCQUFrQixHQUFHLEtBQXJCO0FBQ0EsV0FYRCxNQVdPO0FBQ05DLFlBQUFBLFVBQVUsSUFBSSxHQUFkO0FBQ0E7QUFDRCxTQWhCTSxNQWdCQUEsVUFBVSxJQUFJRSxLQUFkOztBQUNQO0FBQ0E7O0FBRUQsVUFBSSxLQUFLRyxJQUFMLENBQVVILEtBQVYsQ0FBSixFQUFzQjtBQUNyQixZQUFJVixLQUFLLEtBQUssRUFBZCxFQUFtQkUsU0FBUztBQUM1QixPQUZELE1BRU8sSUFBSSxlQUFlVyxJQUFmLENBQW9CSCxLQUFwQixDQUFKLEVBQWdDO0FBQ3RDVixRQUFBQSxLQUFLLElBQUlVLEtBQVQ7QUFDQSxPQUZNLE1BRUE7QUFDTixZQUFJVixLQUFLLEtBQUssRUFBZCxFQUFtQkUsU0FBUzs7QUFDNUIsWUFBSXBCLGdCQUFnQixDQUFDNEIsS0FBRCxDQUFwQixFQUE2QjtBQUM1QixjQUFJYixjQUFjLENBQUNSLE1BQWYsR0FBd0IsQ0FBeEIsSUFBNkJsQixRQUFRLENBQUN1QyxLQUFELENBQVIsQ0FBZXRDLFVBQWYsR0FBNEJELFFBQVEsQ0FBQzBCLGNBQWMsQ0FBQ1QsSUFBZixFQUFELENBQVIsQ0FBZ0NoQixVQUE3RixFQUEwRztBQUN6RyxnQkFBTTBDLEdBQUcsR0FBR2hCLGFBQWEsQ0FBQ08sR0FBZCxFQUFaOztBQUNBLGdCQUFNVSxJQUFHLEdBQUdqQixhQUFhLENBQUNPLEdBQWQsRUFBWjs7QUFDQSxnQkFBTXJCLElBQUUsR0FBR2EsY0FBYyxDQUFDUSxHQUFmLEVBQVg7O0FBQ0FQLFlBQUFBLGFBQWEsQ0FBQ0ssSUFBZCxDQUFtQlQsWUFBWSxDQUFDVixJQUFELEVBQUs4QixHQUFMLEVBQVVDLElBQVYsQ0FBL0I7QUFDQTs7QUFDRGxCLFVBQUFBLGNBQWMsQ0FBQ00sSUFBZixDQUFvQk8sS0FBcEI7QUFDQSxTQVJELE1BUU8sSUFBSXpCLGVBQWUsQ0FBQ3lCLEtBQUQsQ0FBbkIsRUFBNEI7QUFDdEJULFVBQUFBLE9BQU87QUFDUEosVUFBQUEsY0FBYyxDQUFDTSxJQUFmLENBQW9CTyxLQUFwQjtBQUNILFNBSEgsTUFHUSxJQUFJQSxLQUFJLEtBQUssR0FBYixFQUFtQjtBQUNqQ0gsVUFBQUEsa0JBQWtCLEdBQUcsSUFBckI7QUFDQUUsVUFBQUEsUUFBUTtBQUNSLFNBSGMsTUFHUjtBQUNOLGdCQUFNLElBQUlPLEtBQUosaUNBQW1DTixLQUFuQyxPQUFOO0FBQ0E7QUFDRDtBQUNEO0FBaEY2QjtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQWtGOUIsTUFBSUgsa0JBQUosRUFBeUI7QUFDeEIsVUFBTSxJQUFJUyxLQUFKLENBQVUsb0RBQVYsQ0FBTjtBQUNBOztBQUVELE1BQUloQixLQUFLLEtBQUssRUFBZCxFQUFtQkUsU0FBUzs7QUFFNUIsU0FBTUwsY0FBYyxDQUFDUixNQUFmLEdBQXdCLENBQTlCLEVBQWlDO0FBQ2hDLFFBQUl5QixHQUFHLEdBQUd4QixNQUFNLENBQUNRLGFBQWEsQ0FBQ08sR0FBZCxFQUFELENBQWhCO0FBQ0EsUUFBSVUsR0FBRyxHQUFHekIsTUFBTSxDQUFDUSxhQUFhLENBQUNPLEdBQWQsRUFBRCxDQUFoQjtBQUNNLFFBQUlyQixFQUFFLEdBQUdhLGNBQWMsQ0FBQ1EsR0FBZixFQUFUO0FBRU5QLElBQUFBLGFBQWEsQ0FBQ0ssSUFBZCxDQUFtQlQsWUFBWSxDQUFDVixFQUFELEVBQUs4QixHQUFMLEVBQVVDLEdBQVYsQ0FBL0I7QUFDQTs7QUFDRCxNQUFJakIsYUFBYSxDQUFDVCxNQUFkLEdBQXVCLENBQTNCLEVBQStCO0FBQzlCLFVBQU0sSUFBSTJCLEtBQUosQ0FBVSxvQkFBVixDQUFOO0FBQ0c7O0FBRUQsTUFBSUMsTUFBTSxHQUFHM0IsTUFBTSxDQUFDUSxhQUFhLENBQUMsQ0FBRCxDQUFkLENBQW5CO0FBQ0htQixFQUFBQSxNQUFNLENBQUNMLE1BQVAsR0FBZ0JiLGFBQWhCO0FBRUEsU0FBT0QsYUFBYSxDQUFDLENBQUQsQ0FBcEIsQ0F0RzhCLENBc0dMO0FBQ3pCLENBdkdEOztJQXlHTW9CLFU7QUFDRixzQkFBWXRCLEdBQVosRUFBaUI7QUFBQTs7QUFDYixRQUFJLE9BQU9BLEdBQVAsS0FBZSxRQUFuQixFQUE4QjtBQUMxQixZQUFNLElBQUlvQixLQUFKLENBQVUsdURBQVYsQ0FBTjtBQUNIOztBQUNELFNBQUtHLElBQUwsR0FBWXhCLGVBQWUsQ0FBQ0MsR0FBRCxDQUEzQjtBQUNIOzs7O2dDQUNXO0FBQ1IsYUFBTyxLQUFLdUIsSUFBTCxDQUFVUCxNQUFqQjtBQUNIOzs7NkJBQ1FRLE0sRUFBUTtBQUFBLGtEQUNLLEtBQUtELElBQUwsQ0FBVVAsTUFEZjtBQUFBOztBQUFBO0FBQ2IsK0RBQXFDO0FBQUEsY0FBNUJaLEtBQTRCO0FBQ2pDLGNBQUksQ0FBQ29CLE1BQU0sQ0FBQ0MsY0FBUCxDQUFzQnJCLEtBQXRCLENBQUwsRUFBb0MsTUFBTSxJQUFJZ0IsS0FBSixDQUFVLHdEQUFWLENBQU47QUFDdkM7QUFIWTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUliLGFBQU9NLFlBQVksQ0FBQyxLQUFLSCxJQUFOLEVBQVlDLE1BQVosQ0FBbkI7QUFDSDs7Ozs7O0FBR0wsU0FBU0UsWUFBVCxDQUFzQkMsUUFBdEIsRUFBZ0NILE1BQWhDLEVBQXdDO0FBQ3BDLE1BQUlJLENBQUMsR0FBR0QsUUFBUSxDQUFDL0IsS0FBakI7O0FBQ0EsTUFBSWYsVUFBVSxDQUFDK0MsQ0FBRCxDQUFkLEVBQW9CO0FBQ2hCLFFBQUkvQixRQUFRLEdBQUc4QixRQUFRLENBQUM5QixRQUFULENBQWtCZ0MsR0FBbEIsQ0FBc0IsVUFBQUMsQ0FBQztBQUFBLGFBQUlKLFlBQVksQ0FBQ0ksQ0FBRCxFQUFJTixNQUFKLENBQWhCO0FBQUEsS0FBdkIsQ0FBZjtBQUNBLFFBQUlPLElBQUksR0FBR3hELFFBQVEsQ0FBQ3FELENBQUQsQ0FBUixDQUFZbEQsRUFBdkI7QUFDQSxXQUFPcUQsSUFBSSxNQUFKLDRCQUFRbEMsUUFBUixFQUFQO0FBQ0gsR0FKRCxNQUlPO0FBQ0gsV0FBTzJCLE1BQU0sQ0FBQ0ksQ0FBRCxDQUFiO0FBQ0g7QUFDSjs7QUFBQTtlQUVjTixVIiwic291cmNlUm9vdCI6Ii9ob21lL2lzYWFjL1BlcnNvbmFsL3BhcnNlcnMvIiwic291cmNlc0NvbnRlbnQiOlsiLy8gQm9vbGVhbiBFeHByZXNzaW9ucyBQYXJzZXIvRXZhbHVhdG9yXG5cbmNvbnN0IE9QRVJBVE9SID0ge1xuXHQvLyBvcGVyYXRvciBwcmVjZWRlbmNlXG5cdCcqJzoge1xuICAgICAgICBwcmVjZWRlbmNlOiAyLFxuICAgICAgICBiaW5hcnk6IHRydWUsXG5cdFx0Zm46IChhLCBiKSA9PiBhICYmIGJcblx0fSxcblx0JysnOiB7XG4gICAgICAgIHByZWNlZGVuY2U6IDEsXG4gICAgICAgIGJpbmFyeTogdHJ1ZSxcblx0XHRmbjogKGEsIGIpID0+IGEgfHwgYlxuICAgIH0sXG4gICAgJ34nOiB7XG4gICAgICAgIGJpbmFyeTogZmFsc2UsXG4gICAgICAgIGZuOiBhID0+ICFhXG4gICAgfVxufTtcblxuY29uc3QgaXNPcGVyYXRvciA9IGNociA9PiBPYmplY3Qua2V5cyhPUEVSQVRPUikuaW5jbHVkZXMoY2hyKTtcbmNvbnN0IGlzQmluYXJ5T3BlcmF0b3IgPSBjaHIgPT4gT2JqZWN0LmtleXMoT1BFUkFUT1IpLmZpbHRlcihvcCA9PiBPUEVSQVRPUltvcF0uYmluYXJ5KS5pbmNsdWRlcyhjaHIpO1xuY29uc3QgaXNVbmFyeU9wZXJhdG9yID0gY2hyID0+IE9iamVjdC5rZXlzKE9QRVJBVE9SKS5maWx0ZXIob3AgPT4gIU9QRVJBVE9SW29wXS5iaW5hcnkpLmluY2x1ZGVzKGNocik7XG5jb25zdCBzdGFja2lmeSA9IGFyciA9PiB7XG5cdGFyciA9IGFyciB8fCBbXTtcblx0YXJyLnBlZWsgPSAoKSA9PiBhcnJbYXJyLmxlbmd0aC0xXTtcblx0cmV0dXJuIGFycjtcbn07XG5cbmNvbnN0IGZvcm1hdCA9ICh0aykgPT4gdHlwZW9mIHRrID09PSAnc3RyaW5nJyA/IHsgdmFsdWU6IHRrLCBjaGlsZHJlbjogW10gfSA6IHRrO1xuXG5jb25zdCBtYWtlVHJlZU5vZGUgPSAob3AsIGEsIGIpID0+IHtcblx0cmV0dXJuIHtcblx0XHR2YWx1ZTogb3AsXG5cdFx0Y2hpbGRyZW46IFthLCBiXVxuXHR9XG59O1xuXG5jb25zdCBwYXJzZUV4cHJlc3Npb24gPSBleHAgPT4ge1xuXHRjb25zdCBvcGVyYXRvcl9zdGFjayA9IHN0YWNraWZ5KCk7XG5cdGNvbnN0IG9wZXJhbmRfc3RhY2sgPSBzdGFja2lmeSgpO1xuXG5cdGxldCB1bmlxdWVfdG9rZW5zID0gW107XG5cbiAgICBsZXQgdG9rZW4gPSAnJztcblx0bGV0IHVuYXJ5T3AgPSAwO1xuXHRjb25zdCBwdXNoVG9rZW4gPSAoKSA9PiB7XG4gICAgICAgIG9wZXJhbmRfc3RhY2sucHVzaCh0b2tlbik7XG4gICAgICAgIGFnZ3JlZ2F0ZVVuYXJ5T3AoKTtcblx0XHRpZiggIXVuaXF1ZV90b2tlbnMuaW5jbHVkZXModG9rZW4pICkgdW5pcXVlX3Rva2Vucy5wdXNoKHRva2VuKTtcblx0XHR0b2tlbiA9ICcnO1xuICAgIH07XG4gICAgXG4gICAgY29uc3QgYWdncmVnYXRlVW5hcnlPcCA9ICgpID0+IHtcbiAgICAgICAgd2hpbGUoIHVuYXJ5T3AgPiAwICkge1xuICAgICAgICAgICAgbGV0IG9wID0gb3BlcmF0b3Jfc3RhY2sucG9wKCk7XG4gICAgICAgICAgICBsZXQgb3BlcmFuZCA9IG9wZXJhbmRfc3RhY2sucG9wKCk7XG4gICAgICAgICAgICBvcGVyYW5kX3N0YWNrLnB1c2goe1xuICAgICAgICAgICAgICAgIHZhbHVlOiBvcCxcbiAgICAgICAgICAgICAgICBjaGlsZHJlbjogW2Zvcm1hdChvcGVyYW5kKV1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdW5hcnlPcC0tO1xuICAgICAgICB9XG4gICAgfTtcblxuXHRsZXQgZ3JhYmJpbmdFeHByZXNzaW9uID0gZmFsc2U7XG5cdGxldCBleHByZXNzaW9uID0gJyc7XG5cdGxldCBleHBQYXJlbiA9IDA7XG5cdGZvciggbGV0IGNoYXIgb2YgZXhwICkge1xuXHRcdC8vIGZpcnN0IGNoZWNrIGlmIGdyYWJiaW5nIGV4cHJlc3Npb25cblx0XHRpZiggZ3JhYmJpbmdFeHByZXNzaW9uICkge1xuXHRcdFx0aWYoIGNoYXIgPT09ICcoJyApIHtcblx0XHRcdFx0ZXhwUGFyZW4rKztcblx0XHRcdFx0ZXhwcmVzc2lvbiArPSAnKCc7XG5cdFx0XHR9IGVsc2UgaWYoIGNoYXIgPT09ICcpJyApIHtcblx0XHRcdFx0ZXhwUGFyZW4tLTtcblx0XHRcdFx0aWYoIGV4cFBhcmVuID09PSAwICkge1xuXHRcdFx0XHRcdGxldCBleHAgPSBwYXJzZUV4cHJlc3Npb24oZXhwcmVzc2lvbik7XG4gICAgICAgICAgICAgICAgICAgIGxldCBleHBfdGsgPSBleHAudG9rZW5zO1xuICAgICAgICAgICAgICAgICAgICBmb3IoIGxldCB0b2tlbiBvZiBleHBfdGsgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiggIXVuaXF1ZV90b2tlbnMuaW5jbHVkZXModG9rZW4pICkgdW5pcXVlX3Rva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBkZWxldGUgZXhwLnRva2VuczsgLy8gcmVtb3ZlIGV4dHJhbmVvdXMgZGF0YSBmcm9tIGludGVybmFsIHRyZWUgbm9kZXNcbiAgICAgICAgICAgICAgICAgICAgb3BlcmFuZF9zdGFjay5wdXNoKGV4cCk7XG4gICAgICAgICAgICAgICAgICAgIGFnZ3JlZ2F0ZVVuYXJ5T3AoKTtcblx0XHRcdFx0XHRleHByZXNzaW9uID0gJyc7XG5cdFx0XHRcdFx0Z3JhYmJpbmdFeHByZXNzaW9uID0gZmFsc2U7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0ZXhwcmVzc2lvbiArPSAnKSc7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSBleHByZXNzaW9uICs9IGNoYXI7XG5cdFx0XHRjb250aW51ZTtcblx0XHR9XG5cblx0XHRpZiggL1xccy8udGVzdChjaGFyKSApIHtcblx0XHRcdGlmKCB0b2tlbiAhPT0gJycgKSBwdXNoVG9rZW4oKTtcblx0XHR9IGVsc2UgaWYoIC9bYS16QS1aMC05X10vLnRlc3QoY2hhcikgKSB7XG5cdFx0XHR0b2tlbiArPSBjaGFyO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRpZiggdG9rZW4gIT09ICcnICkgcHVzaFRva2VuKCk7XG5cdFx0XHRpZiggaXNCaW5hcnlPcGVyYXRvcihjaGFyKSApIHtcblx0XHRcdFx0aWYoIG9wZXJhdG9yX3N0YWNrLmxlbmd0aCA+IDAgJiYgT1BFUkFUT1JbY2hhcl0ucHJlY2VkZW5jZSA8IE9QRVJBVE9SW29wZXJhdG9yX3N0YWNrLnBlZWsoKV0ucHJlY2VkZW5jZSApIHtcblx0XHRcdFx0XHRjb25zdCBvcDEgPSBvcGVyYW5kX3N0YWNrLnBvcCgpO1xuXHRcdFx0XHRcdGNvbnN0IG9wMiA9IG9wZXJhbmRfc3RhY2sucG9wKCk7XG5cdFx0XHRcdFx0Y29uc3Qgb3AgPSBvcGVyYXRvcl9zdGFjay5wb3AoKTtcblx0XHRcdFx0XHRvcGVyYW5kX3N0YWNrLnB1c2gobWFrZVRyZWVOb2RlKG9wLCBvcDEsIG9wMikpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdG9wZXJhdG9yX3N0YWNrLnB1c2goY2hhcik7XG5cdFx0XHR9IGVsc2UgaWYoIGlzVW5hcnlPcGVyYXRvcihjaGFyKSApIHtcbiAgICAgICAgICAgICAgICB1bmFyeU9wKys7XG4gICAgICAgICAgICAgICAgb3BlcmF0b3Jfc3RhY2sucHVzaChjaGFyKTtcbiAgICAgICAgICAgIH1lbHNlIGlmKCBjaGFyID09PSAnKCcgKSB7XG5cdFx0XHRcdGdyYWJiaW5nRXhwcmVzc2lvbiA9IHRydWU7XG5cdFx0XHRcdGV4cFBhcmVuKys7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoYFVuZXhwZWN0ZWQgY2hhcmFjdGVyICcke2NoYXJ9J2ApO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdGlmKCBncmFiYmluZ0V4cHJlc3Npb24gKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKCdFeHByZXNzaW9uIGNvbnRhaW5zIHVubWF0Y2hlZCBvcGVuaW5nIHBhcmVudGhlc2lzLicpO1xuXHR9XG5cblx0aWYoIHRva2VuICE9PSAnJyApIHB1c2hUb2tlbigpO1xuXG5cdHdoaWxlKG9wZXJhdG9yX3N0YWNrLmxlbmd0aCA+IDApIHtcblx0XHRsZXQgb3AxID0gZm9ybWF0KG9wZXJhbmRfc3RhY2sucG9wKCkpO1xuXHRcdGxldCBvcDIgPSBmb3JtYXQob3BlcmFuZF9zdGFjay5wb3AoKSk7XG4gICAgICAgIGxldCBvcCA9IG9wZXJhdG9yX3N0YWNrLnBvcCgpO1xuXG5cdFx0b3BlcmFuZF9zdGFjay5wdXNoKG1ha2VUcmVlTm9kZShvcCwgb3AxLCBvcDIpKTtcblx0fVxuXHRpZiggb3BlcmFuZF9zdGFjay5sZW5ndGggPiAxICkge1xuXHRcdHRocm93IG5ldyBFcnJvcignVG9vIG1hbnkgb3BlcmFuZHMhJyk7XG4gICAgfVxuXG4gICAgbGV0IHJldE9iaiA9IGZvcm1hdChvcGVyYW5kX3N0YWNrWzBdKTtcblx0cmV0T2JqLnRva2VucyA9IHVuaXF1ZV90b2tlbnM7XG5cblx0cmV0dXJuIG9wZXJhbmRfc3RhY2tbMF07IC8vIHNob3VsZCBiZSB0aGUgZXhwcmVzc2lvbiB0cmVlIChvciBhIHNpbmdsZS10b2tlbiBzdHJpbmcpXG59O1xuXG5jbGFzcyBFeHByZXNzaW9uIHtcbiAgICBjb25zdHJ1Y3RvcihleHApIHtcbiAgICAgICAgaWYoIHR5cGVvZiBleHAgIT09ICdzdHJpbmcnICkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXhwcmVzc2lvbiBjb25zdHJ1Y3RvciB0YWtlcyBpbiBhIGJvb2xlYW4gZXhwcmVzc2lvbi5cIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50cmVlID0gcGFyc2VFeHByZXNzaW9uKGV4cCk7XG4gICAgfVxuICAgIGdldFRva2VucygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJlZS50b2tlbnM7XG4gICAgfVxuICAgIGV2YWx1YXRlKHZhbHVlcykge1xuICAgICAgICBmb3IoIGxldCB0b2tlbiBvZiB0aGlzLnRyZWUudG9rZW5zICkge1xuICAgICAgICAgICAgaWYoICF2YWx1ZXMuaGFzT3duUHJvcGVydHkodG9rZW4pICkgdGhyb3cgbmV3IEVycm9yKFwidmFsdWVzIG11c3QgZGVmaW5lIGEgYm9vbGVhbiB2YWx1ZSBmb3IgZXZlcnkgdmFyaWFibGUuXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBldmFsdWF0ZVRyZWUodGhpcy50cmVlLCB2YWx1ZXMpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZXZhbHVhdGVUcmVlKHRyZWVIZWFkLCB2YWx1ZXMpIHtcbiAgICBsZXQgdiA9IHRyZWVIZWFkLnZhbHVlO1xuICAgIGlmKCBpc09wZXJhdG9yKHYpICkge1xuICAgICAgICBsZXQgY2hpbGRyZW4gPSB0cmVlSGVhZC5jaGlsZHJlbi5tYXAodCA9PiBldmFsdWF0ZVRyZWUodCwgdmFsdWVzKSk7XG4gICAgICAgIGxldCBvcGZuID0gT1BFUkFUT1Jbdl0uZm47XG4gICAgICAgIHJldHVybiBvcGZuKC4uLmNoaWxkcmVuKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdmFsdWVzW3ZdO1xuICAgIH1cbn07XG5cbmV4cG9ydCBkZWZhdWx0IEV4cHJlc3Npb247Il19",
    "map": {
      "version": 3,
      "sources": [
        "boolexp.js"
      ],
      "names": [
        "OPERATOR",
        "precedence",
        "binary",
        "fn",
        "a",
        "b",
        "isOperator",
        "chr",
        "Object",
        "keys",
        "includes",
        "isBinaryOperator",
        "filter",
        "op",
        "isUnaryOperator",
        "stackify",
        "arr",
        "peek",
        "length",
        "format",
        "tk",
        "value",
        "children",
        "makeTreeNode",
        "parseExpression",
        "exp",
        "operator_stack",
        "operand_stack",
        "unique_tokens",
        "token",
        "unaryOp",
        "pushToken",
        "push",
        "aggregateUnaryOp",
        "pop",
        "operand",
        "grabbingExpression",
        "expression",
        "expParen",
        "char",
        "exp_tk",
        "tokens",
        "test",
        "op1",
        "op2",
        "Error",
        "retObj",
        "Expression",
        "tree",
        "values",
        "hasOwnProperty",
        "evaluateTree",
        "treeHead",
        "v",
        "map",
        "t",
        "opfn"
      ],
      "mappings": "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",
      "sourceRoot": "/home/isaac/Personal/parsers/",
      "sourcesContent": [
        "// Boolean Expressions Parser/Evaluator\n\nconst OPERATOR = {\n\t// operator precedence\n\t'*': {\n        precedence: 2,\n        binary: true,\n\t\tfn: (a, b) => a && b\n\t},\n\t'+': {\n        precedence: 1,\n        binary: true,\n\t\tfn: (a, b) => a || b\n    },\n    '~': {\n        binary: false,\n        fn: a => !a\n    }\n};\n\nconst isOperator = chr => Object.keys(OPERATOR).includes(chr);\nconst isBinaryOperator = chr => Object.keys(OPERATOR).filter(op => OPERATOR[op].binary).includes(chr);\nconst isUnaryOperator = chr => Object.keys(OPERATOR).filter(op => !OPERATOR[op].binary).includes(chr);\nconst stackify = arr => {\n\tarr = arr || [];\n\tarr.peek = () => arr[arr.length-1];\n\treturn arr;\n};\n\nconst format = (tk) => typeof tk === 'string' ? { value: tk, children: [] } : tk;\n\nconst makeTreeNode = (op, a, b) => {\n\treturn {\n\t\tvalue: op,\n\t\tchildren: [a, b]\n\t}\n};\n\nconst parseExpression = exp => {\n\tconst operator_stack = stackify();\n\tconst operand_stack = stackify();\n\n\tlet unique_tokens = [];\n\n    let token = '';\n\tlet unaryOp = 0;\n\tconst pushToken = () => {\n        operand_stack.push(token);\n        aggregateUnaryOp();\n\t\tif( !unique_tokens.includes(token) ) unique_tokens.push(token);\n\t\ttoken = '';\n    };\n    \n    const aggregateUnaryOp = () => {\n        while( unaryOp > 0 ) {\n            let op = operator_stack.pop();\n            let operand = operand_stack.pop();\n            operand_stack.push({\n                value: op,\n                children: [format(operand)]\n            });\n            unaryOp--;\n        }\n    };\n\n\tlet grabbingExpression = false;\n\tlet expression = '';\n\tlet expParen = 0;\n\tfor( let char of exp ) {\n\t\t// first check if grabbing expression\n\t\tif( grabbingExpression ) {\n\t\t\tif( char === '(' ) {\n\t\t\t\texpParen++;\n\t\t\t\texpression += '(';\n\t\t\t} else if( char === ')' ) {\n\t\t\t\texpParen--;\n\t\t\t\tif( expParen === 0 ) {\n\t\t\t\t\tlet exp = parseExpression(expression);\n                    let exp_tk = exp.tokens;\n                    for( let token of exp_tk ) {\n                        if( !unique_tokens.includes(token) ) unique_tokens.push(token);\n                    }\n                    delete exp.tokens; // remove extraneous data from internal tree nodes\n                    operand_stack.push(exp);\n                    aggregateUnaryOp();\n\t\t\t\t\texpression = '';\n\t\t\t\t\tgrabbingExpression = false;\n\t\t\t\t} else {\n\t\t\t\t\texpression += ')';\n\t\t\t\t}\n\t\t\t} else expression += char;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif( /\\s/.test(char) ) {\n\t\t\tif( token !== '' ) pushToken();\n\t\t} else if( /[a-zA-Z0-9_]/.test(char) ) {\n\t\t\ttoken += char;\n\t\t} else {\n\t\t\tif( token !== '' ) pushToken();\n\t\t\tif( isBinaryOperator(char) ) {\n\t\t\t\tif( operator_stack.length > 0 && OPERATOR[char].precedence < OPERATOR[operator_stack.peek()].precedence ) {\n\t\t\t\t\tconst op1 = operand_stack.pop();\n\t\t\t\t\tconst op2 = operand_stack.pop();\n\t\t\t\t\tconst op = operator_stack.pop();\n\t\t\t\t\toperand_stack.push(makeTreeNode(op, op1, op2));\n\t\t\t\t}\n\t\t\t\toperator_stack.push(char);\n\t\t\t} else if( isUnaryOperator(char) ) {\n                unaryOp++;\n                operator_stack.push(char);\n            }else if( char === '(' ) {\n\t\t\t\tgrabbingExpression = true;\n\t\t\t\texpParen++;\n\t\t\t} else {\n\t\t\t\tthrow new Error(`Unexpected character '${char}'`);\n\t\t\t}\n\t\t}\n\t}\n\n\tif( grabbingExpression ) {\n\t\tthrow new Error('Expression contains unmatched opening parenthesis.');\n\t}\n\n\tif( token !== '' ) pushToken();\n\n\twhile(operator_stack.length > 0) {\n\t\tlet op1 = format(operand_stack.pop());\n\t\tlet op2 = format(operand_stack.pop());\n        let op = operator_stack.pop();\n\n\t\toperand_stack.push(makeTreeNode(op, op1, op2));\n\t}\n\tif( operand_stack.length > 1 ) {\n\t\tthrow new Error('Too many operands!');\n    }\n\n    let retObj = format(operand_stack[0]);\n\tretObj.tokens = unique_tokens;\n\n\treturn operand_stack[0]; // should be the expression tree (or a single-token string)\n};\n\nclass Expression {\n    constructor(exp) {\n        if( typeof exp !== 'string' ) {\n            throw new Error(\"Expression constructor takes in a boolean expression.\");\n        }\n        this.tree = parseExpression(exp);\n    }\n    getTokens() {\n        return this.tree.tokens;\n    }\n    evaluate(values) {\n        for( let token of this.tree.tokens ) {\n            if( !values.hasOwnProperty(token) ) throw new Error(\"values must define a boolean value for every variable.\");\n        }\n        return evaluateTree(this.tree, values);\n    }\n}\n\nfunction evaluateTree(treeHead, values) {\n    let v = treeHead.value;\n    if( isOperator(v) ) {\n        let children = treeHead.children.map(t => evaluateTree(t, values));\n        let opfn = OPERATOR[v].fn;\n        return opfn(...children);\n    } else {\n        return values[v];\n    }\n};\n\nexport default Expression;"
      ]
    },
    "sourceType": "script",
    "mtime": 1591213652603
  }
}